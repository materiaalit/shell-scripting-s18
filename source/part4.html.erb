---
  title: Osa 4
  exercise_page: true
  quiz_page: true
  published: false
---



<% partial 'partials/material_heading' do %>
  Tiedon lukeminen tiedostosta
<% end %>



<% partial 'partials/material_heading' do %>
  Tiedostot ja tiedon lukeminen
<% end %>


<p>
  Merkittävä osa ohjelmistoista perustuu tavalla tai toisella tiedon käsittelyyn. Musiikin toistoon tarkoitetut ohjelmistot käsittelevät musiikkitiedostoja, kuvankäsittelyohjelmat käsittelevät kuvatiedostoja. Verkossa ja mobiililaitteissa toimivat sovellukset kuten Facebook ja WhatsApp taas käsittelevät muunmuassa tietokantoihin tallennettuja henkilötietoja. Kaikissa näistä sovelluksista on yhteistä tiedon lukeminen, tiedon käsitteleminen tavalla tai toisella sekä se, että käsiteltävä tieto on loppujenlopulta tallennettu jonkinlaisessa muodossa yhteen tai useampaan tiedostoon.
</p>


<% partial 'partials/material_sub_heading' do %>
  Lukeminen näppäimistöltä
<% end %>

<p>
  Olemme käyttäneet Scanner-luokkaa näppäimistöllä kirjoitetun syötteen lukemiseen kurssin alusta lähtien. Tiedon lukemiseen käytetty runko on while-true -toistolause, missä lukeminen lopetetaan tietynmuotoiseen syötteeseen.
</p>

<% partial 'partials/code_highlight' do %>
// luodaan Scanner-olio, joka lukee näppäimistösyötettä
Scanner lukija = new Scanner(System.in);

// jatketaan syötteen lukemista kunnes käyttäjä syöttää
// rivin "loppu"
while (true) {
    String rivi = lukija.nextLine();

    if (rivi.equals("loppu")) {
        break;
    }

    // lisää luettu rivi myöhempää käsittelyä varten
    // tai käsittele rivi
}

// käsittele myöhempää käsittelyä varten lisätyt rivit
<% end %>

<p>
  Yllä Scanner-luokan konstruktorille annetaan parametrina järjestelmän syöte (<code>System.in</code>). Tekstikäyttöliittymissä käyttäjän kirjoittama tieto ohjataan syötevirtaan rivi kerrallaan, eli tieto lähetetään käsiteltäväksi aina kun käyttäjä painaa rivinvaihtoa.
</p>


<% partial 'partials/exercise', locals: { name: 'Arvosanatilastot (4 osaa)' } do %>

  <p>
    Tässä tehtävässä toteutetaan ohjelma kurssipistetilastojen tulostamiseen. Ohjelmalle syötetään pisteitä (kokonaislukuja nollasta sataan), ja ohjelma tulostaa niiden perusteella arvosanoihin liittyviä tilastoja. Syötteiden lukeminen lopetetaan kun käyttäjä syöttää luvun -1. Lukuja, jotka eivät ole välillä [0-100] ei tule ottaa huomioon tilastojen laskemisessa.
  </p>

  <p>
    Muistathan, että käyttäjältä luetun merkkijonon saa muunnettua kokonaisluvuksi Integer-luokan metodilla parseInt. Tämä toimii seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
    String lukuMerkkijonona = "3";
    int luku = Integer.parseInt(lukuMerkkijonona);

    System.out.println(lukuMerkkijonona + 7);
    System.out.println(luku + 7);
  <% end %>

  <% partial 'partials/sample_output' do %>
    37
    10
  <% end %>

  <h2>Pisteiden keskiarvot</h2>

  <p>
    Kirjoita ohjelma, joka lukee käyttäjältä kurssin yhteispisteitä kuvaavia kokonaislukuja. Luvut väliltä [0-100] ovat hyväksyttäviä ja luku -1 lopettaa syötteen. Muut luvut ovat virhesyötteitä, jotka tulee jättää huomiotta. Kun käyttäjä syöttää luvun -1, tulostetaan syötettyjen yhteispisteiden keskiarvo.
  </p>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">-42</font>
    <font color="red">24</font>
    <font color="red">42</font>
    <font color="red">72</font>
    <font color="red">80</font>
    <font color="red">52</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 54.0
  <% end %>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">50</font>
    <font color="red">51</font>
    <font color="red">52</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 51.0
  <% end %>


  <h2>Hyväksyttyyn arvosanaan liittyvien pisteiden keskiarvot</h2>

  <p>
    Täydennä ohjelmaa siten, että se laskee kaikkien pisteiden keskiarvon lisäksi myös hyväksyttyyn arvosanaan liittyvien pisteiden keskiarvot.
  </p>

  <p>
    Hyväksytyn arvosanan saa vähintään 70 kurssipisteellä. Voit olettaa, että käyttäjä kirjoittaa aina vähintään yhden välillä [0-100] olevan kokonaisluvun. Jos hyväksyttyyn arvosanaan osuvia lukuja ei ole lainkaan, tulostetaan viiva hyväksyttyjen keskiarvon kohdalle "-".
  </p>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">-42</font>
    <font color="red">24</font>
    <font color="red">42</font>
    <font color="red">72</font>
    <font color="red">80</font>
    <font color="red">52</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 54.0
    Pisteiden keskiarvo (hyväksytyt): 76.0
  <% end %>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">50</font>
    <font color="red">51</font>
    <font color="red">52</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 51.0
    Pisteiden keskiarvo (hyväksytyt): -
  <% end %>


  <h2>Hyväksyttyjen prosenttiosuus</h2>

  <p>
    Täydennä edellisessä osassa toteuttamaasi ohjelmaa siten, että ohjelma tulostaa myös hyväksymisprosentin. Hyväksymisprosentti lasketaan kaavalla <em>100 * hyväksytyt / osallistujat</em>.
  </p>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">50</font>
    <font color="red">51</font>
    <font color="red">52</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 51.0
    Pisteiden keskiarvo (hyväksytyt): -
    Hyväksymisprosentti: 0.0
  <% end %>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">102</font>
    <font color="red">-4</font>
    <font color="red">33</font>
    <font color="red">77</font>
    <font color="red">99</font>
    <font color="red">1</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 52.5
    Pisteiden keskiarvo (hyväksytyt): 88.0
    Hyväksymisprosentti: 50.0
  <% end %>


  <h2>Arvosanajakauma</h2>

  <p>
    Täydennä ohjelmaa siten, että ohjelma tulostaa myös arvosanajakauman. Arvosananajakauma muodostetaan seuraavasti.
  </p>

  <table class="table">

    <tr>
      <th>pistemäärä</th>
      <th>arvosana</th>
    </tr>

    <tr>
      <td>&lt; 70</td>
      <td>hylätty eli 0</td>
    </tr>

    <tr>
      <td>&lt; 76</td>
      <td>1</td>
    </tr>

    <tr>
      <td>&lt; 81</td>
      <td>2</td>
    </tr>

    <tr>
      <td>&lt; 86</td>
      <td>3</td>
    </tr>

    <tr>
      <td>&lt; 91</td>
      <td>4</td>
    </tr>

    <tr>
      <td>&gt;= 91</td>
      <td>5</td>
    </tr>

  </table>


  <p>
    Jokainen koepistemäärä muutetaan arvosanaksi yllä olevan taulukon perusteella. Jos syötetty pistemäärä ei ole välillä [0-100], jätetään se huomiotta.
  </p>

  <p>
    Arvosanajakauma tulostetaan tähtinä. Esim jos arvosanaan 5 oikeuttavia koepistemääriä on 1 kappale, tulostuu rivi <em>5: *</em>. Jos johonkin arvosanaan oikeuttavia pistemääriä ei ole, ei yhtään tähteä tulostu, alla olevassa esimerkissä näin on mm. nelosten kohdalla.</em>
  </p>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">102</font>
    <font color="red">-2</font>
    <font color="red">1</font>
    <font color="red">33</font>
    <font color="red">77</font>
    <font color="red">99</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 52.5
    Pisteiden keskiarvo (hyväksytyt): 88.0
    Hyväksymisprosentti: 50.0
    Arvosanajakauma:
    5: *
    4:
    3:
    2: *
    1:
    0: **
  <% end %>

<% end %>




<% partial 'partials/material_sub_heading' do %>
  Lukeminen tiedostosta
<% end %>

<p>
  Tiedostot ovat tietokoneella sijaitsevia tietokokoelmia, jotka voivat sisältää vaikkapa tekstiä, kuvia, musiikkia tai niiden yhdistelmiä. Tiedoston tallennusmuoto määrittelee tiedoston sisällön sekä tavan tiedon lukemiseen. Esimerkiksi PDF-tiedostoja luetaan PDF-tiedostojen lukemiseen soveltuvalla ohjelmalla ja musiikkitiedostoja luetaan musiikkitiedostojen lukemiseen soveltuvalla ohjelmalla. Jokainen näistä ohjelmista on ihmisen luoma, ja ohjelman luoja tai luojat -- eli ohjelmoijat -- ovat osana työtään myös määritelleet tiedoston tallennusmuodon.
</p>


<% partial 'partials/hint', locals: { name: 'Tiedoston sijainti' } do %>

  <p>
    Voit käydä tarkastelemassa NetBeansissa kaikkia projektiin liittyviä tiedostoja valitsemalla <code>Files</code>-välilehden. Jos tiedosto on projektin juuressa, saa sen auki File-olion avulla vain nimen perusteella. Jos taas tiedosto on jossain muualla, tulee myös sen polku kertoa.
  </p>

<% end %>

<% partial 'partials/exercise', locals: { name: 'Uuden tiedoston luominen' } do %>

  <p>
    Tässä tehtävässä ei ohjelmoida, vaan tutustutaan tiedoston luomiseen.
  </p>

  <p>
    Luo tehtäväpohjan juurikansioon (samassa kansiossa mm. kansiot <code>src</code> ja <code>test</code>) tiedosto nimeltä <code>tiedosto.txt</code>. Muokkaa tiedostoa, ja kirjoita tiedoston ensimmäisen rivin alkuun viesti <code>Hei maailma</code>.
  </p>

<% end %>



<p>
  Tiedoston lukeminen tapahtuu tutun Scanner-luokan avulla. Kun Scanner-luokan avulla halutaan lukea tiedosto, annetaan luokan konstruktorille parametrina luettavaa tiedostoa kuvaava tiedosto-olio. Tämän jälkeen tiedostoa voi lukea kuten näppäimistöltä luettavaa syötettä. Lukeminen tapahtuu while-toistolauseella, jota jatketaan kunnes kaikki tiedoston rivit on luettu.
</p>


<p>
  Alla olevassa esimerkissä luetaan tiedoston "tiedosto.txt" kaikki rivit, jotka lisätään ArrayList-listaan. Tiedostoja lukiessa voidaan kohdata virhetilanne, joten tiedoston lukeminen vaatii erillisen "yrittämisen" (try) sekä mahdollisen virheen kiinnioton (catch). Palaamme virhetilanteiden käsittelyyn ohjelmoinnin jatkokurssilla.
</p>


<% partial 'partials/code_highlight' do %>
ArrayList&lt;String&gt; rivit = new ArrayList&lt;&gt;();

// luodaan lukija tiedoston lukemista varten
try (Scanner lukija = new Scanner(new File("tiedosto.txt"))) {

    // luetaan kaikki tiedoston rivit
    while (lukija.hasNextLine()) {
        rivit.add(lukija.nextLine());
    }
} catch (Exception e) {
    System.out.println("Virhe: " + e.getMessage());
}

// tee jotain luetuilla riveillä
<% end %>


<% partial 'partials/exercise', locals: { name: 'Vieraslista tiedostosta' } do %>


  <p>
    Tehtäväpohjassa on valmiina toiminnallisuus vieraslistaohjelmaan, missä käyttäjän syöttämien nimien olemassaolo tarkistetaan vieraslistalta.
  </p>

  <p>
    Ohjelmasta puuttuu kuitenkin toiminnallisuus vieraslistan lukemiseen. Muokkaa ohjelmaa siten, että vieraslistan nimet luetaan tiedostosta.
  </p>

  <% partial 'partials/sample_output' do %>
Minkä niminen tiedosto luetaan?
<font color="red">vieraslista.txt</font>

Syötä nimiä, tyhjä rivi lopettaa.
<font color="red">Chuck Norris</font>
Nimi ei ole listalla.
<font color="red">Jack Baluer</font>
Nimi ei ole listalla.
<font color="red">Jack Bauer</font>
Nimi on listalla.
<font color="red">Jack Bower</font>
Nimi on listalla.

Kiitos!
  <% end %>


  <p>
    Huom! Tehtäväpohjassa on mukana kaksi tiedostoa, <code>nimet.txt</code> ja <code>toiset-nimet.txt</code>, joiden sisällöt ovat seuravat. Älä muuta näiden tiedostojen sisältöä!
  </p>

  <p>
    nimet.txt:
  </p>

  <% partial 'partials/sample_output' do %>
ada
arto
leena
testi
  <% end %>

  <p>
    toiset-nimet.txt:
  </p>

  <% partial 'partials/sample_output' do %>
leo
jarmo
alicia
  <% end %>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Löytyykö tiedostosta?' } do %>

  <p>
    Tehtäväpohjassa tulee kaksi tekstitiedostoa: <code>nimet.txt</code> ja <code>toiset-nimet.txt</code>. Kirjoita ohjelma, joka kysyy ensin käyttäjältä luettavan tiedoston nimeä, jonka jälkeen käyttäjältä kysytään etsittävää merkkijonoa. Tämän jälkeen ohjelma lukee tiedoston ja etsii tiedostosta haluttua merkkijonoa.
  </p>

  <p>
    Jos merkkijono löytyy, ohjelman tulee tulostaa "Löytyi!". Jos merkkijonoa ei löydy, ohjelman tulee tulostaa "Ei löytynyt.". Jos tiedoston lukeminen epäonnistuu (lukeminen päätyy virhetilanteeseen), ohjelman tulee tulostaa viesti "Tiedoston lukeminen epäonnistui.".
  </p>

  <% partial 'partials/sample_output' do %>
    Minkä niminen tiedosto luetaan?
    <font color="red">nimet.txt</font>
    Mitä etsitään?
    <font color="red">Antti</font>
    Ei löytynyt.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Minkä niminen tiedosto luetaan?
    <font color="red">nimet.txt</font>
    Mitä etsitään?
    <font color="red">ada</font>
    Löytyi!
  <% end %>

  <% partial 'partials/sample_output' do %>
    Minkä niminen tiedosto luetaan?
    <font color="red">olematon.txt</font>
    Mitä etsitään?
    <font color="red">testi</font>
    Tiedoston olematon.txt lukeminen epäonnistui.
  <% end %>

<% end %>



<% partial 'partials/exercise', locals: { name: 'Mittaukset tiedostosta' } do %>

  <p>
    Toteuta ohjelma, joka lukee käyttäjältä tiedoston nimen sekä hyväksyttävien lukujen ala- ja ylärajan. Tämän jälkeen ohjelma lukee tiedoston sisältämät luvut (jokainen luku on omalla rivillään) ja ottaa huomioon vain ne luvut, jotka ovat annetulla lukuvälillä. Lopulta ohjelma tulostaa annetulla lukuvälillä olleiden lukujen lukumäärän.
  </p>

  <% partial 'partials/sample_output' do %>
Tiedosto? <font color="red">mittaukset-1.txt</font>
Alaraja? <font color="red">15</font>
Yläraja? <font color="red">20</font>
Lukuja: 2
  <% end %>

  <% partial 'partials/sample_output' do %>
Tiedosto? <font color="red">mittaukset-1.txt</font>
Alaraja? <font color="red">0</font>
Yläraja? <font color="red">300</font>
Lukuja: 4
  <% end %>

  <p>
    Huom! Tehtäväpohjassa on mukana kaksi tiedostoa, <code>mittaukset-1.txt</code> ja <code>mittaukset-2.txt</code>, joiden sisällöt ovat seuravat. Älä muuta näiden tiedostojen sisältöä.
  </p>

  <p>mittaukset-1.txt:</p>

  <% partial 'partials/sample_output' do %>
300
9
20
15
  <% end %>

  <p>mittaukset-2.txt:</p>

  <% partial 'partials/sample_output' do %>
123
-5
12
67
-300
1902
  <% end %>

<% end %>



<% partial 'partials/material_sub_heading' do %>
  Monimutkaisemman tiedon lukeminen
<% end %>

<p>
  Edellisessä esimerkissä sekä sitä seuranneissa tehtävissä tiedoston sisältö käsiteltiin riveittäin lukuina tai merkkijonoina. Mikäli tiedosto noudattaa jonkinlaista ennalta määrättyä rakennetta ja sen sisältämä tieto liittyy konkreettiseen käsitteeseen, voidaan luetut rivit muuttaa myös olioiksi.
</p>

<p>
  Oletetaan, että käytössämme on seuraavaa muotoa noudattava reseptejä sisältävä tiedosto. Tiedosto sisältää aina ensin reseptin nimen, jota seuraa reseptiin liittyvät raaka-aineet. Raaka-aineita seuraa tyhjä rivi, jonka jälkeen alkaa uusi resepti. Tiedoston muoto on siis seuraava
</p>

<% partial 'partials/sample_output' do %>
  Reseptin 1 nimi
  reseptin 1 raaka-aine 1
  reseptin 1 raaka-aine 2

  Reseptin 2 nimi
  reseptin 2 raaka-aine 1
  reseptin 2 raaka-aine 2
  reseptin 2 raaka-aine 3
  reseptin 2 raaka-aine 4

  Reseptin 3 nimi
  reseptin 3 raaka-aine 1
  reseptin 3 raaka-aine 2
  reseptin 3 raaka-aine 3
  reseptin 3 raaka-aine 4
<% end %>

<p>
  Käsitettä <code>Resepti</code> voidaan luoda kuvaamaan seuraavanlainen luokka, joka sisältää sekä nimen että listan raaka-aineita.
</p>

<% partial 'partials/code_highlight' do %>
  import java.util.ArrayList;

  public class Resepti {
      private String nimi;
      private ArrayList&lt;String&gt; raakaAineet;

      public Resepti(String nimi) {
          this.nimi = nimi;
          this.raakaAineet = new ArrayList&lt;&gt;();
      }

      public void lisaaRaakaAine(String raakaAine) {
          this.raakaAineet.add(raakaAine);
      }

      public String toString() {
          String palautettava = this.nimi;
          for (String raakaAine: this.raakaAineet) {
              palautettava += "\n  " + raakaAine;
          }
          return palautettava;
      }
  }
<% end %>

<% partial 'partials/code_highlight' do %>
  Resepti resepti = new Resepti("Lettutaikina");
  resepti.lisaaRaakaAine("0.5 litraa maitoa");
  resepti.lisaaRaakaAine("2 munaa");
  resepti.lisaaRaakaAine("sopivasti jauhoa");
  resepti.lisaaRaakaAine("0.5 tl suolaa");
  resepti.lisaaRaakaAine("2 rkl sokeria");
  resepti.lisaaRaakaAine("voita paistamiseen");

  System.out.println(resepti);
<% end %>

<% partial 'partials/sample_output' do %>
  Lettutaikina
    0.5 litraa maitoa
    2 munaa
    sopivasti jauhoa
    0.5 tl suolaa
    2 rkl sokeria
    voita paistamiseen
<% end %>

<p>
  Nyt tiedoston lukeminen onnistuu seuraavasti.
</p>


<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Resepti&gt; reseptit = new ArrayList&lt;&gt;();
  Scanner lukija = new Scanner(System.in);
  System.out.println("Mistä tiedostosta luetaan?");
  String tiedosto = lukija.nextLine();

  try (Scanner tiedostonLukija = new Scanner(new File(tiedosto))) {

      // luetaan reseptit ja raaka-aineet
      while (tiedostonLukija.hasNextLine()) {
          // luetaan resepti ja luodaan sitä vastaava olio
          String reseptinNimi = tiedostonLukija.nextLine();
          Resepti resepti = new Resepti(reseptinNimi);

          // lisätään resepti listalle
          reseptit.add(resepti);

          // lisätään reseptiin raaka-aineet
          while (tiedostonLukija.hasNextLine()) {
              String raakaAine = tiedostonLukija.nextLine();

              // reseptin raaka-aineet lopetetaan tyhjällä rivillä
              if(raakaAine.isEmpty()) {
                  // poistutaan tästä while-toistolauseesta
                  // (ulompi jatkaa)
                  break;
              }

              resepti.lisaaRaakaAine(raakaAine);
          }

      }
  } catch (Exception e) {
      System.out.println("Virhe: " + e.getMessage());
  }

  // tee jotain luetuilla resepteillä
<% end %>


<%= partial 'partials/quiz', locals: { id: '5a874484c1b9900004293f60' } %>

<%= partial 'partials/quiz', locals: { id: '5a87457fc1b9900004293f62' } %>

<%= partial 'partials/quiz', locals: { id: '5a8745e7c1b9900004293f63' } %>



<% partial 'partials/exercise', locals: { name: 'Reseptihaku (4 osaa)' } do %>

  <p>
    Tässä tehtävässä tehdään ohjelma, joka tarjoaa käyttäjälle mahdollisuuden reseptien hakuun reseptin nimen, keittoajan tai raaka-aineen nimen perusteella. Ohjelman tulee lukea reseptit käyttäjän antamasta tiedostosta.
  </p>

  <p>
    Jokainen resepti koostuu kolmesta tai useammasta rivistä reseptitiedostossa. Ensimmäisellä rivillä on reseptin nimi, toisella rivillä reseptin keittoaika (kokonaisluku), ja kolmas ja sitä seuraavat rivit kertovat reseptin raaka-aineet. Reseptin raaka-aineiden kuvaus päättyy tyhjään riviin. Tiedostossa voi olla useampia reseptejä. Alla kuvattuna esimerkkitiedosto.
  </p>

  <% partial 'partials/sample_output' do %>
    Lettutaikina
    60
    maito
    muna
    jauho
    sokeri
    suola
    voi

    Lihapullat
    20
    jauheliha
    muna
    korppujauho

    Tofurullat
    30
    tofu
    riisi
    vesi
    porkkana
    kurkku
    avokado
    wasabi
  <% end %>

  <p>
    Ohjelma toteutetaan osissa. Ensin ohjelmaan luodaan mahdollisuus reseptien lukemiseen sekä listaamiseen. Tämän jälkeen ohjelmaan lisätään mahdollisuus reseptien hakemiseen nimen perusteella, keittoajan perusteella ja lopulta raaka-aineen perusteella.
  </p>

  <p>
    Tehtäväpohjassa on mukana tiedosto <code>reseptit.txt</code>, jota voi käyttää sovelluksen testaamiseen. <em>Huomaa, että ohjelman ei tule listata reseptien raaka-aineita, mutta niitä käytetään hakutoiminnallisuudessa.</em>
  </p>


  <h2>
    Reseptien lukeminen ja listaaminen
  </h2>

  <p>
    Luo ohjelmaan ensin mahdollisuus reseptien lukemiseen sekä listaamiseen. Ohjelman käyttöliittymän tulee olla seuraavanlainen. Voit olettaa, että käyttäjä syöttää aina tiedoston, joka on olemassa. Alla oletetaan, että tehtävänannossa annetut esimerkkireseptit ovat tiedostossa <code>reseptit.txt</code>.
  </p>

  <% partial 'partials/sample_output' do %>
    Mistä luetaan? <font color="red">reseptit.txt</font>

    Komennot:
    listaa - listaa reseptit
    lopeta - lopettaa ohjelman

    Syötä komento: <font color="red">listaa</font>

    Reseptit:
    Lettutaikina, keittoaika: 60
    Lihapullat, keittoaika: 20
    Tofurullat, keittoaika: 30

    Syötä komento:  <font color="red">lopeta</font>
  <% end %>


  <h2>
    Reseptien hakeminen nimen perusteella
  </h2>

  <p>
    Lisää ohjelmaan mahdollisuus reseptien hakemiseen nimen perusteella. Nimen perusteella hakeminen tapahtuu komennolla <code>hae nimi</code>, jonka jälkeen käyttäjältä kysytään merkkijonoa, jota etsitään reseptin nimistä. Hakutoiminnallisuuden tulee toimia siten, että se tulostaa kaikki ne reseptit, joiden nimessä esiintyy käyttäjän kirjoittama merkkijono.
  </p>


  <% partial 'partials/sample_output' do %>
    Mistä luetaan? <font color="red">reseptit.txt</font>

    Komennot:
    listaa - listaa reseptit
    lopeta - lopettaa ohjelman
    hae nimi - hakee reseptiä nimen perusteella

    Syötä komento: <font color="red">listaa</font>

    Reseptit:
    Lettutaikina, keittoaika: 60
    Lihapullat, keittoaika: 20
    Tofurullat, keittoaika: 30

    Syötä komento: <font color="red">hae nimi</font>
    Mitä haetaan: <font color="red">rulla</font>

    Reseptit:
    Tofurullat, keittoaika: 30

    Syötä komento:  <font color="red">lopeta</font>
  <% end %>


  <h2>
    Reseptien hakeminen keittoajan perusteella
  </h2>

  <p>
    Lisää seuraavaksi ohjelmaan mahdollisuus reseptien hakemiseen keittoajan perusteella. Keittoajan perusteella hakeminen tapahtuu komennolla <code>hae keittoaika</code>, jonka jälkeen käyttäjältä kysytään suurinta hyväksyttävää keittoaikaa. Hakutoiminnallisuuden tulee toimia siten, että se tulostaa kaikki ne reseptit, joiden keittoaika on pienempi tai yhtä suuri kuin käyttäjän syöttämä keittoaika.
  </p>


  <% partial 'partials/sample_output' do %>
    Mistä luetaan? <font color="red">reseptit.txt</font>

    Komennot:
    listaa - listaa reseptit
    lopeta - lopettaa ohjelman
    hae nimi - hakee reseptiä nimen perusteella
    hae keittoaika - hakee reseptiä keittoajan perusteella

    Syötä komento: <font color="red">hae keittoaika</font>
    Keittoaika korkeintaan: <font color="red">30</font>

    Reseptit:
    Lihapullat, keittoaika: 20
    Tofurullat, keittoaika: 30

    Syötä komento: <font color="red">hae keittoaika</font>
    Keittoaika korkeintaan: <font color="red">15</font>

    Reseptit:

    Syötä komento: <font color="red">hae nimi</font>
    Mitä haetaan: <font color="red">rulla</font>

    Reseptit:
    Tofurullat, keittoaika: 30

    Syötä komento:  <font color="red">lopeta</font>
  <% end %>


  <h2>
    Reseptien hakeminen raaka-aineen perusteella
  </h2>

  <p>
    Lisää lopulta ohjelmaan mahdollisuus reseptien hakemiseen raaka-aineen perusteella. Raaka-aineen perusteella hakeminen tapahtuu komennolla <code>hae aine</code>, jonka jälkeen käyttäjältä kysytään merkkijonoa. Hakutoiminnallisuuden tulee toimia siten, että se tulostaa kaikki ne reseptit, joiden raaka-aineissa esiintyy käyttäjän antama merkkijono. Huomaa, että tässä annetun merkkijonon täytyy vastata täysin haettua raaka-ainetta (esim. "okeri" ei käy ole sama kuin "sokeri").
  </p>

  <% partial 'partials/sample_output' do %>
    Mistä luetaan? <font color="red">reseptit.txt</font>

    Komennot:
    listaa - listaa reseptit
    lopeta - lopettaa ohjelman
    hae nimi - hakee reseptiä nimen perusteella
    hae keittoaika - hakee reseptiä keittoajan perusteella
    hae aine - hakee reseptiä raaka-aineen perusteella

    Syötä komento: <font color="red">hae keittoaika</font>
    Keittoaika korkeintaan: <font color="red">30</font>

    Reseptit:
    Lihapullat, keittoaika: 20
    Tofurullat, keittoaika: 30

    Syötä komento: <font color="red">hae aine</font>
    Mitä raaka-ainetta haetaan: <font color="red">sokeri</font>

    Reseptit:
    Lettutaikina, keittoaika: 60

    Syötä komento: <font color="red">hae aine</font>
    Mitä raaka-ainetta haetaan: <font color="red">muna</font>

    Reseptit:
    Lettutaikina, keittoaika: 60
    Lihapullat, keittoaika: 20

    Syötä komento: <font color="red">hae aine</font>
    Mitä raaka-ainetta haetaan: <font color="red">una</font>

    Reseptit:

    Syötä komento:  <font color="red">lopeta</font>
  <% end %>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Lukeminen verkkoyhteyden yli
<% end %>

<p>
  Lähes kaikki verkkosivut, kuten tämäkin oppimateriaali, voidaan lukea tekstimuodossa ohjelmallista käsittelyä varten. Scanner-oliolle voi antaa konstruktorin parametrina lähes minkälaisen syötevirran tahansa. Alla olevassa esimerkissä luodaan URL-olio annetusta web-osoitteesta, pyydetään siihen liittyvää tietovirtaa, ja annetaan se uudelle Scanner-oliolle luettavaksi.
</p>


<% partial 'partials/code_highlight' do %>
ArrayList&lt;String&gt; rivit = new ArrayList&lt;&gt;();

// luodaan lukija web-osoitteen lukemista varten
try (Scanner lukija = new Scanner(new URL("http://www.cs.helsinki.fi/home/").openStream())) {

    // luetaan osoitteesta http://www.cs.helsinki.fi/home/
    // saatava vastaus
    while (lukija.hasNextLine()) {
        rivit.add(lukija.nextLine());
    }
} catch (Exception e) {
    System.out.println("Virhe: " + e.getMessage());
}

// tehdään jotain vastauksella
<% end %>

<p>
  Web-selain on oikeastaan ohjelma siinä missä muutkin ohjelmat. Toisin kuin yllä toteutettu sivun sisällön lataaja, web-selaimeen on toteutettu toiminnallisuus vastauksena tulevan HTML-muotoisen lähdekoodin tulkisemiseen ja graafisessa käyttöliittymässä näyttämiseen.
</p>


<% partial 'partials/exercise', locals: { name: 'Chuck Norris -vitsit' } do %>

  <p>
    Osoitteessa <a href="http://www.icndb.com/api/" target="_blank" rel="noopener">http://www.icndb.com/api/</a> sijaitsee web-sovellus, joka tarjoaa Chuck Norris -vitsejä kaikkien vapaaseen käyttöön.
  </p>

  <p>
    Sovellus tarjoaa muunmuassa mahdollisuuden satunnaisten vitsien hakemiseen (osoite <code>http://api.icndb.com/jokes/random</code>) sekä vitsien hakemiseen niihin liittyvillä numeerisilla tunnuksilla (osoite <code>http://api.icndb.com/jokes/<em>tunnus</em></code>, missä <em>tunnus</em> on kokonaisluku).
  </p>

  <p>
    Toteuta sovellus, joka tarjoaa kolme toimintoa. Jos käyttäjä kirjoittaa "lopeta", ohjelman suoritus lopetetaan. Jos käyttäjä kirjoittaa "satunnainen", ohjelma tulostaa icndb-palvelusta noudetun satunnaisen chuck norris vitsin. Jos käyttäjä kirjoittaa "vitsi <em>numero</em>", missä numero on kokonaisluku, ohjelma tulostaa icndb-palvelusta noudetun tietyn vitsin.
  </p>

  <p>
    Huom! Tässä tehtävässä riittää tulostaa palvelun palauttama merkkijono kokonaisuudessaan. Merkkijono voi olla esimerkiksi muotoa <code>{ "type": "success", "value": { "id": 341, "joke": "Chuck Norris sleeps with a pillow under his gun.", "categories": [] } }</code>.
  </p>

  <p>
    Ohjelmassa ei ole testejä, eli testit eivät ota kantaa sovelluksen rakenteeseen tai tulostuksen ulkoasuun. Palauta sovellus kun se toimii koneellasi toivotulla tavalla.
  </p>

<% end %>





<% partial 'partials/material_heading' do %>
  Luokka ja olio
<% end %>


<br/>

<pre>
psvm {
    Scanner s = new Scanner(System.in);

    Olio munolio = new Olio();
    String nimi = s.nextLine();
    munolio.setNimi(nimi);
    munolio.setJotain(jotainmuuta);
 
    System.out.println(munolio)
}
</pre>

<pre>
  cs: input/output
</pre>

miten crowdsorcererilla testataan luokkia ja olioita?
---


<p>
  Tutustuimme edellisessä osassa ensimmäistä kertaa termeihin olio ja luokka. Aloitamme nyt matkan olio-ohjelmoinnin pariin.
</p>

<p>
  Olio-ohjelmoinnissa on kyse ratkaistavassa ongelmassa esiintyvien käsitteiden eristämisestä omiksi kokonaisuuksikseen sekä näiden kokonaisuuksien käyttämistä ongelman ratkaisemisessa. Kun ongelmaan liittyvät käsitteet on tunnistettu, niistä voidaan myös keskustella. Toisin ajatellen, ratkaistavasta ongelmasta muodostetaan abstraktioita, joiden avulla ongelmaa on helpompi käsitellä.
</p>

<p>
  Kun ongelmasta tunnistetaan käsitteitä, voidaan niitä vastaavia rakenteita luoda myös ohjelmaan. Näitä rakenteita ja niistä luotavia yksittäisiä ilmentymiä eli olioita käytetään ongelman ratkaisemisessa. Nyt ehkä käsittämättömältä tuntuva lausahdus <strong>ohjelma rakennetaan pienistä selkeistä yhteistoiminnassa olevista olioista</strong> alkaa hiljalleen kurssin edetessä tuntua järkeenkäyvältä ja jopa itsestäänselvältä.
</p>


<% partial 'partials/material_sub_heading' do %>
  Luokka ja Olio
<% end %>

<p>
  Olemme käyttäneet jo joitakin Javan tarjoamia luokkia ja olioita. <strong>Luokka</strong> määrittelee olioiden ominaisuudet eli niihin liittyvät tiedot eli oliomuuttujat ja niiden tarjoamat komennot eli metodit. Oliomuuttujien arvot määrittelevät yksittäisen olion sisäisen tilan ja metodit taas olion tarjoamat toiminnallisuudet. <strong>Olio</strong> luodaan luokkaan kirjoitetun määrittelyn perusteella. Samasta luokasta voidaan luoda useampia olioita, joilla jokaisella on eri tila eli jokaisella on omat oliomuuttujien arvot. Jokaisella oliolla on myös metodit, jotka olion luomiseen käytetyssä luokassa on määritelty.
</p>

<p>
  <strong>Metodi</strong> on luokkaan kirjoitettu lähdekoodista koostuva kokonaisuus, jolle on annettu nimi, ja jota voidaan kutsua. Metodi liittyy aina tiettyyn luokkaan, ja sitä käytetään usein luokasta tehdyn olion sisäisen tilan muokkaamiseen.
</p>

<p>
  Esimerkiksi <code>Scanner</code> on Javan tarjoama luokka, josta luotuja olioita olemme hyödyntäneet ohjelmissamme. Alla ohjelmassa luodaan Scanner-olio nimeltä <code>lukija</code>, jota käytetään kokonaislukumuuttujien lukemiseen.
</p>


<% partial 'partials/code_highlight' do %>
  // luodaan Scanner-luokasta olio, jonka nimeksi tulee lukija
  Scanner lukija = new Scanner(System.in);

  while (true) {
      int luku = Integer.parseInt(lukija.nextLine());

      if (luku == 0) {
          break;
      }

      System.out.println("Luettu " + luku);
  }
<% end %>


<p>
  Luokasta luodaan olio aina kutsumalla olion luovaa metodia eli <strong>konstruktoria</strong> komennon <code>new</code> avulla. Esimerkiksi <code>Scanner</code>-luokasta luodaan uusi ilmentymä eli olio kun kutsutaan <code>new Scanner(..)</code>. Konstruktorit saavat parametreja kuten muutkin metodit.
</p>

<% partial 'partials/hint', locals: { name: 'Luokan ja olion suhde' } do %>

  <p>
    Luokka kuvaa siitä luotavien olioiden "rakennuspiirustukset". Otetaan analogia tietokoneiden ulkopuoleisesta maailmasta. Rintamamiestalot lienevät monille tuttuja. Voidaan ajatella, että jossain on olemassa piirustukset jotka määrittelevät minkälainen rintamamiestalo on. Piirrustukset ovat luokka, eli ne määrittelevät minkälaisia olioita luokasta voidaan luoda:
  </p>

  <p>
    <img src="/img/rintamamiestalo-rakennuspiirrustus.jpg"/>
  </p>

  <p>
    Yksittäiset oliot eli rintamamiestalot on tehty samojen piirustusten perusteella, eli ne ovat saman luokan ilmentymiä. Yksittäisten olioiden tila eli ominaisuudet (esim. seinien väri, katon rakennusmateriaali ja väri, kivijalan väri, ovien rakennusmateriaali ja väri, ...) vaihtelevat. Seuraavassa yksi "rintamamiestalo-luokan olio":
  </p>

  <p>
    <img src="/img/rintamamiestalo.jpg" height=250 />
  </p>

<% end %>


<% partial 'partials/hint', locals: { name: 'Visuaalinen johdanto oliohin' } do %>

  <p>
    Osoitteessa <a href="https://emo-2014.herokuapp.com" target="_blank" norel">https://emo-2014.herokuapp.com</a> on visuaalinen johdanto olio-ohjelmointiin. Johdannon läpikäynti vie korkeintaan 15 minuuttia -- katso kyseinen johdanto nyt.
  </p>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Ensimmäinen tilisi' } do %>

  <p>
    Tehtäväpohjan mukana tulee valmis luokka <code>Tili</code>. Luokan <code>Tili</code> olio esittää pankkitiliä, jolla on saldo (eli jossa on jokin määrä rahaa). Tilejä käytetään näin:
  </p>

  <% partial 'partials/code_highlight' do %>
    Tili artonTili = new Tili("Arton tili", 100.00);
    Tili artonSveitsilainenTili = new Tili("Arton tili Sveitsissä", 1000000.00);

    System.out.println("Alkutilanne");
    System.out.println(artonTili);
    System.out.println(artonSveitsilainenTili);

    artonTili.otto(20);
    System.out.println("Arton tilin saldo on nyt: " + artonTili.saldo());
    artonSveitsilainenTili.pano(200);
    System.out.println("Arton toisen tilin saldo on nyt: " + artonSveitsilainenTili.saldo());

    System.out.println("Lopputilanne");
    System.out.println(artonTili);
    System.out.println(artonSveitsilainenTili);
  <% end %>

  <p>
    Tee ohjelma, joka luo tilin jonka saldo on 100.0, panee tilille 20.0 ja tulostaa tilin. <strong>Huom!</strong> tee kaikki nämä operaatiot täsmälleen tässä järjestyksessä.
  </p>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Ensimmäinen tilisiirtosi' } do %>

  <p>
    Tässäkin tehtävässä on käytössä edellisessä tehtävässä mukana ollut luokka <code>Tili</code>.
  </p>
  
  <p>
    Tee ohjelma joka:
  </p>

  <ol class="lista">
    <li>Luo tilin nimeltä <code>"Matin tili"</code> saldolla 1000</li>
    <li>Luo tilin nimeltä <code>"Oma tili"</code> saldolla 0</li>
    <li>Nostaa matin tililtä 100.0</li>
    <li>Panee omalle tilille 100.0</li>
    <li>Tulostaa molemmat tilit</li>
  </ol>
  
<% end %>

<% partial 'partials/material_sub_heading' do %>
  Luokan luominen
<% end %>


<p>
  <strong>Luokka määrittelee</strong> minkälaisia luokasta luotavat oliot ovat:
</p>

<ul>
  <li><strong>olion muuttujat</strong> määrittelevät minkälainen olion sisäinen tila on </li>
  <li><strong>olion metodit</strong> määrittelevät mitä toiminnallisuuksia olio tarjoaa</li>
</ul>

<p>
  Tutustutaan seuraavaksi oman luokan luomiseen sekä luokkaan liittyvien oliomuuttujien määrittelyyn.
</p>


<p>
  Luokka määritellään kuvaamaan jotain mielekästä kokonaisuutta. Usein "mielekäs kokonaisuus" kuvaa jotain reaalimaailman asiaa tai käsitettä. Jos tietokoneohjelman pitää käsitellä henkilötietoja, voisi olla mielekästä määritellä erillinen luokka <code>Henkilo</code> joka kokoaa yhteen henkilöön liittyvät metodit ja ominaisuudet.
</p>

<p>
  Aloitetaan. Oletetaan että meillä on projektirunko jossa on tyhjä pääohjelma:
</p>

<% partial 'partials/code_highlight' do %>
  public class Main {

      public static void main(String[] args) {

      }
  }
<% end %>



<% partial 'partials/hint', locals: { name: 'Uuden luokan luominen' } do %>

  <p>
    Uuden luokan luominen NetBeansissa tapahtuu valitsemalla vasemmalta <em>projects</em>-kohdasta hiiren oikealla napilla <em>new</em> ja <em>java class</em>. Avautuvaan dialogiin annetaan luokalle nimi.
  </p>

  <p>
    Kuten muuttujien ja metodien nimien, myös luokan nimen on aina oltava mahdollisimman kuvaava. Usein ohjelmoinnin edetessä luokka elää ja muuttaa muotoaan, joten on myös mahdollista että luokka nimetään uudelleen.
  </p>


  <p>
    <em>
      Luokkien, muuttujien ja metodien nimissä ei tyypillisesti käytetä ääkkösiä. Vältä niiden käyttöä myös tässä.
    </em>
  </p>

<% end %>

<p>
  Luodaan luokka nimeltä <code>Henkilo</code>. Luokkaa varten luodaan erillinen tiedosto nimeltä <code>Henkilo.java</code>. Ohjelmamme koostuu nyt siis kahdesta erillisestä tiedostosta, sillä myös pääohjelma on omassa tiedostossaan. Aluksi Henkilo.java -tiedosto sisältää luokan määrittelyn <strong>public class Henkilo</strong> sekä luokan sisällön rajaavat aaltosulut.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {

  }
<% end %>

<p>
  Luokkaa kuvaamaan voi piirtää myös luokkakaavion, jonka merkintätekniikkaan tutustutaan tässä samalla. Henkilo-niminen luokka, jossa ei ole mitään sisällä näyttää seuraavalta:
</p>

<p>
  <img src="/img/diagrams/luokkakaavio-henkilo.png">
</p>

<p>
  Luokka määrittelee luokasta luotavien olioiden ominaisuudet ja toiminnallisuudet. Päätetään, että jokaisella henkilöoliolla on nimi ja ikä. Nimi on luonnollista esittää merkkijonona, eli Stringinä, ja ikä taas kokonaislukuna. Lisätään nämä rakennuspiirustuksiimme:
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      private String nimi;
      private int ika;
  }
<% end %>

<p>
  Määrittelimme yllä että jokaisella <code>Henkilo</code>-luokasta luotavalla oliolla on <code>nimi</code> ja <code>ika</code>. Luokan sisälle määriteltyjä muuttujia kutsutaan <strong>oliomuuttujiksi</strong> tai olion kentiksi tai olion attribuuteiksi. Muitakin nimiä tuntuu löytyvän.
</p>

<p>
  Oliomuuttujat kirjoitetaan luokan määrittelyä "public class Henkilo {" seuraaville riveille. Jokaisen muuttujan eteen asetetaan avainsana private. Avainsana <strong>private</strong> tarkoittaa sitä, että muuttujat ovat "piilossa" olion sisällä. Tätä kutsutaan <strong>kapseloinniksi</strong>.
</p>

<p>
  Luokkaakaaviossa luokkaan liittyvät muuttujat määritellään muodossa "muuttujanNimi: muuttujanTyyppi". Miinusmerkki ennen muuttujan nimeä kertoo, että muuttuja on kapseloitu (sillä on avainsana private).
</p>

<p>
  <img src="/img/diagrams/luokkakaavio-henkilo-ika-ja-nimi.png">
</p>

<p>
  Olemme nyt määritelleet rakennuspiirustukset -- luokan -- henkilöoliolle. Jokaisella uudella henkilöolioilla on muuttujat <code>nimi</code> ja <code>ika</code>, joissa voi olla oliokohtainen arvo. Henkilöiden "tila" koostuu niiden nimeen ja ikään asetetuista arvoista.
</p>


<% partial 'partials/exercise', locals: { name: 'Koiran ominaisuudet' } do %>

  <p>
    Uuden luokan saa lisättyä NetBeansissa seuraavasti: Ruudun vasemmalla reunalla on projektilistaus (Projects). Paina projektin nimen kohdalla hiiren oikeaa nappia. Valitse avautuvasta valikosta <em>New</em> ja <em>Java Class</em>. Anna luokan nimeksi (Class Name) <code>Koira</code>.
  </p>

  <p>
    Tässä tehtävässä harjoittelet luokan luomista. Luo tehtäväpohjaan luokka nimeltä <code>Koira</code> ja lisää sille oliomuuttujat <code>private String nimi</code>, <code>private String rotu</code> ja <code>private int ika</code>. Luokkakaaviona luokka näyttää seuraavalta:
  </p>

  <p>
    <img src="/img/diagrams/luokkakaavio-teht-koira.png" alt="[Koira|-nimi:String;-rotu:String;-ika:int]">
  </p>


  <p>
    Luokalla ei vielä oikeastaan tee mitään, mutta tämän askeleen harjoittelusta on hyötyä myöhempää ajatellen.
  </p>

<% end %>



<% partial 'partials/material_sub_heading' do %>
  Konstruktorin määrittely
<% end %>

<p>
  Konstruktoria käytetään olion luomiseen.
</p>

<p>
  Luotavalle oliolle halutaan asettaa alkutila. Itse määritellyn olion luominen tapahtuu hyvin samaan tapaan kuin olioiden luominen Javan valmiista luokista kuten <code>ArrayList</code>istä. Oliot luodaan <code>new</code>-komennolla. Olion luomisen yhteydessä on kätevää pystyä antamaan arvot luotavan olion muuttujille. Esimerkiksi uutta henkilö-oliota luotaessa olisi kätevää pystyä antamaan oliolle nimi:
</p>

<% partial 'partials/code_highlight' do %>
  public static void main(String[] args) {
      Henkilo ada = new Henkilo("Ada");
      // ...
  }
<% end %>

<p>
  Tämä onnistuu määrittelemällä olion luova metodi eli <strong>konstruktori</strong>. Konstruktori määritellään oliomuuttujien jälkeen. Seuraavassa esimerkissä Henkilo-luokalle on määritelty konstruktori, jota voidaan käyttää uuden Henkilo-olion luomiseen. Konstruktori asettaa luotavan olion iäksi 0 ja nimeksi konstruktorin parametrina annettavan merkkijonon:
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      private String nimi;
      private int ika;

      public Henkilo(String nimiAlussa) {
          this.ika = 0;
          this.nimi = nimiAlussa;
      }
  }
<% end %>

<p>
  Konstruktorin nimi on aina sama kuin luokan nimi. Yllä luokka (<em>class</em>) on Henkilo, joten konstruktorin nimeksi tulee Henkilo. Konstruktorille annetaan lisäksi parametrina luotavan henkilööolion nimi. Parametri asetetaan sulkuihin konstruktorin nimen perään. Parametreja mahdollisesti sisältävien sulkujen jälkeen tulee aaltosulut, joiden sisälle määritellään lähdekoodi, jonka ohjelma suorittaa konstruktorikutsun (esim. <code>new Henkilo("Ada")</code>) yhteydessä.
</p>

<p>
  Oliot luodaan aina konstruktorin avulla.
</p>

<p>
  Muutama huomio: konstruktorin sisällä on lauseke <code>this.ika = 0</code>. Lausekkeessa asetetaan juuri luotavan olion (eli "tämän" olion) oliomuuttujan ika arvoksi 0. Toinen lauseke <code>this.nimi = nimiAlussa;</code> taas asettaa juuri tämän olion sisäiselle muuttujalle <code>nimi</code> arvoksi parametrina annetun merkkijonon.
</p>

<p>
  Koska oliomuuttujat on määritelty konstruktorin aaltosulkujen ulkopuolella, voi niitä käyttää myös konstruktorin sisällä.
</p>

<p>
  Nyt luokkakaavioon on merkitty luokan nimen ja muuttujien lisäksi myös konstruktori. Konstruktori saa public näkyvyysmääreen takia eteen plussan, jonka lisäksi siitä merkitään sen nimi ja parametrin tyypit (tässä <code>+ Henkilo(String)</code>).
</p>

<p>
  <img src="/img/diagrams/luokkakaavio-henkilo-ika-ja-nimi-ja-konstruktori.png">
</p>

<p>
  Vielä yksi huomio: jos ohjelmoija ei tee luokalle konstruktoria, tekee Java automaattisesti luokalle oletuskonstruktorin. Oletuskonstruktori on konstruktori joka ei tee mitään. Jos konstruktoria ei jostain syystä tarvita, ei sellaista tarvitse ohjelmoida.
</p>


<% partial 'partials/exercise', locals: { name: 'Luokkahuone' } do %>

  <p>
    Uuden luokan saa lisättyä seuraavasti: Ruudun vasemmalla reunalla on projektilistaus. Paina projektin nimen kohdalla hiiren oikeaa nappia. Valitse avautuvasta valikosta <em>New</em> ja <em>Java Class</em>. Jos haluat että luokan nimi on Luokkahuone, aseta luokan nimeksi (Class Name) <code>Luokkahuone</code>.
  </p>

  <p>
    Luo luokka nimeltä <code>Luokkahuone</code>. Luokkahuoneella on oliomuuttujina <code>private String koodi</code>, esimerkiksi "B221", ja <code>private int istumapaikat</code>, esimerkiksi 30. Luo tämän jälkeen konstruktori <code>public Luokkahuone(String luokanKoodi, int istumapaikkojenMaara)</code>, minkä avulla oliomuuttujiin asetetaan arvot.
  </p>

  <p>
    <img src="/img/diagrams/luokkakaavio-teht-luokka.png" alt="[Luokkahuone|-koodi:String;-istumapaikat:int|+Luokkahuone(String‚ int)]">
  </p>

  <p>
    Tälläkään luokalla ei vielä oikeastaan tee mitään, mutta seuraavassa tehtävässä luokastamme tehty olio osaa jo tulostaa tekstiä.
  </p>

<% end %>



<% partial 'partials/material_sub_heading' do %>
  Metodien määrittely
<% end %>

<p>
  Alkaa olla korkea aika päästä käyttämään Henkilo-luokasta luotuja olioita. Osaamme luoda olion ja alustaa olion muuttujat. Toimintaan pystyäkseen olioilla on oltava myös metodeja. <strong>Metodi</strong> on luokkaan kirjoitettu lähdekoodista koostuva kokonaisuus, jolle on annettu nimi, ja jota voidaan kutsua. Metodi liittyy aina tiettyyn luokkaan, ja sitä käytetään usein luokasta tehdyn olion sisäisen tilan muokkaamiseen.
</p>

<p>
  Tehdään luokalle Henkilo metodi, jota käytetään olion tietojen tulostamiseen.
</p>


<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      private String nimi;
      private int ika;

      public Henkilo(String nimiAlussa) {
          this.ika = 0;
          this.nimi = nimiAlussa;
      }

      public void tulostaHenkilo() {
          System.out.println(this.nimi + ", ikä " + this.ika + " vuotta");
      }
  }
<% end %>

<p>
  Metodi kirjoitetaan luokan sisälle konstruktorin alapuolelle. Metodin nimen eteen tulee <code>public void</code> sillä metodin on tarkoitus näkyä ulkomaailmalle ("public") ja metodi ei palauta arvoa ("void").
</p>

<% partial 'partials/hint', locals: { name: 'Oliot ja määre static' } do %>

  <p>
    Aiemmin toteuttamissamme metodeissa on ollut käytössä määre <code>static</code>. Määre <code>static</code> viittaa siihen, että metodi ei liity olioon ja sen avulla ei voi käsitellä oliolle määriteltyjä muuttujia.
  </p>

  <p>
    Metodeistamme puuttuu jatkossa määre <code>static</code> jos ne käsittelevät olioiden tietoa. Jos taas metodit eivät käsittele olioihin liittyvää tietoa, niissä voidaan käyttää määrettä static.
  </p>

<% end %>

<p>
  Luokkakaavioon on merkitty luokan nimen, oliomuuttujien ja konstruktorin lisäksi nyt myös metodi <code>tulostaHenkilo</code>. Koska metodilla on public-määre, tulee sille alkuun plus, jota seuraa metodin nimi. Metodille ei ole määritelty parametreja, joten ei myöskään piirretä metodin sulkujen sisälle. Metodille merkitään myös tieto siitä, että se ei palauta arvoa, tässä "void".
</p>

<p>
  <img src="/img/diagrams/luokkakaavio-henkilo-ika-ja-nimi-ja-konstruktori-ja-tulosta.png">
</p>

<p>
  Metodin <code>tulostaHenkilo</code> sisällä on yksi koodirivi joka käyttää hyvakseen oliomuuttujia <code>nimi</code> ja <code>ika</code> -- luokkakaavio ei kerro sisäisestä toteutuksesta. Olion sisäisiin muuttujiin viitataan etuliitteellä <code>this</code>. Kaikki olion muuttujat ovat siis näkyvillä ja käytettävissä metodin sisällä.
</p>

<p>
  Luodaan pääohjelmassa kolme henkilöä ja pyydetään niitä tulostamaan itsensä:
</p>

<% partial 'partials/code_highlight' do %>
  public class Main {

      public static void main(String[] args) {
          Henkilo ada = new Henkilo("Ada");
          Henkilo antti = new Henkilo("Antti");
          Henkilo martin = new Henkilo("Martin");

          ada.tulostaHenkilo();
          antti.tulostaHenkilo();
          martin.tulostaHenkilo();
      }
  }
<% end %>

<p>
  Tulostuu:
</p>

<% partial 'partials/sample_output' do %>
  Ada, ikä 0 vuotta
  Antti, ikä 0 vuotta
  Martin, ikä 0 vuotta
<% end %>


<p>
  Sama screencastina:
</p>

<a href="http://www.youtube.com/watch?feature=player_embedded&v=fWwXQ5n2gYo" class="youtube" height="300" target="_blank" rel="noopener"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

<p>
  &nbsp;
</p>


<% partial 'partials/exercise', locals: { name: 'Pilli' } do %>

  <p>
    Luo luokka nimeltä <code>Pilli</code>. Pillillä on oliomuuttujina <code>private String aani</code>. Luo tämän jälkeen konstruktori <code>public Pilli(String pillinAani)</code>, minkä avulla luodaan uusi pilli, jolle annetaan ääni.
  </p>

  <p>
    Lisää pillille vielä metodi <code>public void soi()</code>, joka tulostaa pillin äänen.
  </p>

  <p>
    Pillin tulee toimia seuraavasti.
  </p>

  <% partial 'partials/code_highlight' do %>
    Pilli sorsapilli = new Pilli("Kvaak");
    Pilli kukkopilli = new Pilli("Peef");

    sorsapilli.soi();
    kukkopilli.soi();
    sorsapilli.soi();
  <% end %>

  <% partial 'partials/sample_output' do %>
    Kvaak
    Peef
    Kvaak
  <% end %>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Ovi' } do %>

  <p>
    Luo luokka nimeltä <code>Ovi</code>. Ovella ei ole oliomuuttujia. Luo sille parametriton konstruktori (tai käytä oletuskonstruktoria).  Luo tämän jälkeen ovelle metodi <code>public void koputa()</code>, jota kutsuttaessa tulostuu viesti "Who's there?".
  </p>

  <p>
    Oven tulee toimia seuraavasti.
  </p>

  <% partial 'partials/code_highlight' do %>
    Ovi alexander = new Ovi();

    alexander.koputa();
    alexander.koputa();
  <% end %>

  <% partial 'partials/sample_output' do %>
    Who's there?
    Who's there?
  <% end %>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Tuote' } do %>

  <p>
    Luo luokka <code>Tuote</code> joka esittää kaupan tuotetta jolla on hinta, lukumäärä ja nimi.
  </p>

  <p>
    Uuden luokan saa lisättyä seuraavasti: Ruudun vasemmalla reunalla on projektilistaus. Paina projektin nimen kohdalla hiiren oikeaa nappia. Valitse avautuvasta valikosta <em>New</em> ja <em>Java Class</em>. Anna luokan nimeksi (Class Name) <code>Tuote</code>.
  </p>

  <p>
    Luokalla tulee olla:
  </p>

  <ul>
    <li>Konstruktori <code>public Tuote(String nimiAlussa, double hintaAlussa, int maaraAlussa)</code></li>
    <li>Metodi <code>public void tulostaTuote()</code> joka tulostaa tuotteen tiedot tässä muodossa:
      <% partial 'partials/sample_output' do %>
Banaani, hinta 1.1, 13 kpl
      <% end %>
    </li>
  </ul>

  <p>
    Piirrä myös luokkaan liittyvä luokkakaavio itsellesi!
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Oliomuuttujan arvon muuttaminen metodissa
<% end %>

<p>
  Lisätään aiemmin rakentamallemme Henkilo-luokalle metodi, joka kasvattaa henkilön ikää vuodella:
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      // ...

      public void vanhene() {
          this.ika = this.ika + 1;
      }
  }
<% end %>

<p>
  Metodi kirjoitetaan <code>tulostaHenkilo</code>-metodin tapaan luokan <code>Henkilo</code> sisälle. Metodissa kasvatetaan oliomuuttujan <code>ika</code> arvoa yhdellä.
</p>

<p>
  Myös luokkakaavio päivittyy.
</p>

<p>
  <img src="/img/diagrams/luokkakaavio-henkilo-ika-ja-nimi-ja-konstruktori-ja-tulosta-ja-vanhene.png" alt="[Henkilo|-nimi:String;-ika:int|+Henkilo(String);+tulostaHenkilo():void;+vanhene():void]">
</p>


<p>
  Kutsutaan metodia ja katsotaan mitä tapahtuu:
</p>

<% partial 'partials/code_highlight' do %>
  public class Main {

      public static void main(String[] args) {
          Henkilo ada = new Henkilo("Ada");
          Henkilo antti = new Henkilo("Antti");

          ada.tulostaHenkilo();
          antti.tulostaHenkilo();

          System.out.println("");

          ada.vanhene();
          ada.vanhene();

          ada.tulostaHenkilo();
          antti.tulostaHenkilo();
      }
  }
<% end %>

<p>
  Ohjelman tulostus on seuraava:
</p>

<% partial 'partials/sample_output' do %>
  Ada, ikä 0 vuotta
  Antti, ikä 0 vuotta

  Ada, ikä 2 vuotta
  Antti, ikä 0 vuotta
<% end %>

<p>
  Eli "syntyessään" molemmat oliot ovat nollavuotiaita (konstruktorissa suoritetaan mm. rivi <code>this.ika = 0;</code>). Olion <code>ada</code> metodia <code>vanhene</code> kutsutaan kaksi kertaa. Kuten tulostus näyttää, tämä saa aikaan sen että Adan ikä on vanhenemisen jälkeen 2 vuotta. Kutsumalla metodia Adaa vastaavalle oliolle, toisen henkilöolion ikä ei muutu, sillä jokaiselle luokasta luotavalle oliolle luodaan myös omat oliomuuttujat.
</p>

<p>
  Metodin sisään voi lisätä myös ehto- ja toistolauseita. Alla olevaa vanhene-metodia käytettäessä kenestäkään ei tulisi yli 30-vuotiasta.
</p>


<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      // ...

      public void vanhene() {
          if (this.ika &lt; 30) {
              this.ika = this.ika + 1;
          }
      }
  }
<% end %>


<% partial 'partials/exercise', locals: { name: 'Vähenevä laskuri (4 osaa)' } do %>

  <p>
    Tässä tehtävässä on useampi osa. Jokainen osa vastaa yhtä tehtäväpistettä.
  </p>

  <p>
    Tehtäväpohjan mukana tulee osittain valmiiksi toteutettu luokka <code>VahenevaLaskuri</code>:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class VahenevaLaskuri {
        private int arvo;   // oliomuuttuja joka muistaa laskurin arvon

        public VahenevaLaskuri(int arvoAlussa) {
            this.arvo = arvoAlussa;
        }

        public void tulostaArvo() {
            System.out.println("arvo: " + this.arvo);
        }

        public void vahene() {
            // kirjoita tänne metodin toteutus
            // laskurin arvon on siis tarkoitus vähentyä yhdellä
        }

        // ja tänne muut metodit
    }
  <% end %>

  <p>
    Seuraavassa esimerkki miten pääohjelma käyttää vähenevää laskuria:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            VahenevaLaskuri laskuri = new VahenevaLaskuri(10);

            laskuri.tulostaArvo();

            laskuri.vahene();
            laskuri.tulostaArvo();

            laskuri.vahene();
            laskuri.tulostaArvo();
        }
    }
  <% end %>

  <p>
    Pitäisi tulostua:
  </p>

  <% partial 'partials/sample_output' do %>
    arvo: 10
    arvo: 9
    arvo: 8
  <% end %>

  <p>
    <code>VahenevaLaskuri</code>-luokan konstruktorille annetaan parametrina alkuarvo. Esimerkin oliota <code>laskuri</code> luodessa laskurille välitetään parametrina arvo <code>10</code>. Esimerkin <code>laskuri</code>-olioon liittyvään oliomuuttujaan <code>arvo</code> asetetaan siis aluksi arvo <code>10</code>. Laskurin arvon voi tulostaa metodilla <code>tulostaArvo()</code>. Laskurilla tulee myös olla metodi <code>vahene()</code> joka vähentää laskurin arvoa yhdellä.
  </p>


  <h2>Metodin vahene() toteutus</h2>

  <p>
    Täydennä luokan runkoon metodin <code>vahene()</code> toteutus sellaiseksi, että se vähentää kutsuttavan olion oliomuuttujan <code>arvo</code> arvoa yhdellä. Kun olet toteuttanut metodin <code>vahene()</code>, edellisen esimerkin pääohjelman tulee toimia esimerkkitulosteen mukaan.
  </p>


  <h2>Laskurin arvo ei saa olla negatiivinen</h2>

  <p>
    Täydennä metodin <code>vahene()</code> toteutus sellaiseksi, ettei laskurin arvo mene koskaan negatiiviseksi. Eli jos laskurin arvo on jo 0, ei vähennys sitä enää vähennä. Ehtolause auttaa tässä.
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            VahenevaLaskuri laskuri = new VahenevaLaskuri(2);

            laskuri.tulostaArvo();

            laskuri.vahene();
            laskuri.tulostaArvo();

            laskuri.vahene();
            laskuri.tulostaArvo();

            laskuri.vahene();
            laskuri.tulostaArvo();
        }
    }
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    arvo: 2
    arvo: 1
    arvo: 0
    arvo: 0
  <% end %>


  <h2>Laskurin arvon nollaus</h2>

  <p>
    Tee laskurille metodi <code>public void nollaa()</code> joka nollaa laskurin arvon, esim:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            VahenevaLaskuri laskuri = new VahenevaLaskuri(100);

            laskuri.tulostaArvo();
 
            laskuri.nollaa();
            laskuri.tulostaArvo();

            laskuri.vahene();
            laskuri.tulostaArvo();
        }
    }
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    arvo: 100
    arvo: 0
    arvo: 0
  <% end %>


  <h2>Laskurin arvon palautus</h2>


  <p>
    Tee laskurille metodi <code>public void palautaAlkuarvo()</code>, joka palauttaa laskurille arvon joka sillä oli alussa:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            VahenevaLaskuri laskuri = new VahenevaLaskuri(100);

            laskuri.tulostaArvo();

            laskuri.vahene();
            laskuri.tulostaArvo();

            laskuri.vahene();
            laskuri.tulostaArvo();

            laskuri.nollaa();
            laskuri.tulostaArvo();

            laskuri.palautaAlkuarvo();
            laskuri.tulostaArvo();
        }
    }
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    arvo: 100
    arvo: 99
    arvo: 98
    arvo: 0
    arvo: 100
  <% end %>


  <p>
    <strong>Vihje</strong> jotta alkuarvon voi palauttaa, se täytyy "muistaa" toisen oliomuuttujan avulla! Joudut siis lisäämään ohjelmaan toisen oliomuuttujan johon talletetaan laskurin alussa saama arvo.
  </p>

<% end %>

<% partial 'partials/exercise', locals: { name: 'Velka' } do %>

  <p>
    Luo luokka <code>Velka</code>, jolla on double-tyyppiset oliomuuttujat <code>saldo</code> ja <code>korkokerroin</code>. Saldo ja korkokerroin annetaan konstruktorin parametrina <code>public Velka(double saldoAlussa, double korkokerroinAlussa)</code>.
  </p>
  
  <p>
    Luo luokalle myös metodit <code>public void tulostaSaldo()</code> sekä <code>public void odotaVuosi()</code>. Metodi tulostaSaldo tulostaa tämän hetkisen saldon, ja metodi odotaVuosi kasvattaa velan määrää.
  </p>
  
  <p>
    Velan määrän kasvattaminen tapahtuu kertomalla saldo korkokertoimella.
  </p>

  <p>
    Luokan tulee toimia seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {

            Velka asuntolaina = new Velka(120000.0, 1.01);
            asuntolaina.tulostaSaldo();

            asuntolaina.odotaVuosi();
            asuntolaina.tulostaSaldo();

            int vuosia = 0;

            while (vuosia &lt; 20) {
                asuntolaina.odotaVuosi();
                vuosia++;
            }

            asuntolaina.tulostaSaldo();
        }
    }
  <% end %>

  <p>
    Ylläolevassa esimerkissä havainnollistetaan asuntolainan kehitystä prosentin korolla.
  </p>

  <p>Tulostus:</p>

  <% partial 'partials/sample_output' do %>
    120000.0
    121200.0
    147887.0328416936
  <% end %>

  <p>
    Kun saat ohjelman toimimaan, tarkastele edelläolevaa esimerkkiä myös 1990-luvun alkupuolen laman korkokertoimilla. Tällöin korko oli jopa 15-20 prosenttia -- muuta yllä olevan esimerkin korkokertoimeksi <code>1.20</code> ja katso miten käy.
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Arvon palauttaminen metodista
<% end %>


<p>
  Metodi voi palauttaa arvon. Tähän mennessä olioihin luomamme metodit eivät palauttaneet mitään. Tämä on merkitty kirjoittamalla metodin määrittelyyn avainsana <em>void</em>.
</p>

<% partial 'partials/code_highlight' do %>
  public class Ovi {
      public void koputa() {
          // ...
      }
  }
<% end %>

<p>
  Avainsana <strong>void</strong> tarkoittaa että metodi ei palauta arvoa.
</p>

<p>
  Jos haluamme, että metodi palauttaa arvon, tulee avainsanan <code>void</code> paikalle asettaa palautettavan muuttujan tyyppi. Seuraavassa esimerkissä näkyvälle luokalle Opettaja on määritelty metodi <code>arvostele</code>, joka palauttaa aina kokonaislukutyyppisen (<code>int</code>) muuttujan (tässä arvo 10). Arvon palauttaminen tapahtuu aina komennolla <strong>return</strong>:
</p>

<% partial 'partials/code_highlight' do %>
  public class Opettaja {
      public int arvostele() {
          return 10;
      }
  }
<% end %>

<p>
  Ylläoleva metodi siis palauttaa sitä kutsuttaessa <code>int</code>-tyyppisen arvon <code>10</code>. Jotta metodin palauttamaa arvoa voisi käyttää, tulee se ottaa talteen muuttujaan. Tämä tapahtuu samalla tavalla kuin normaali muuttujan arvon asetus, eli yhtäsuuruusmerkillä:
</p>

<% partial 'partials/code_highlight' do %>
  public static void main(String[] args) {
      Opettaja opettaja = new Opettaja();

      int arvostelu = opettaja.arvostele();

      System.out.println("Arvosanaksi tuli " + arvostelu);
  }
<% end %>

<% partial 'partials/sample_output' do %>
Arvosanaksi tuli 10
<% end %>

<p>
  Metodin paluuarvo sijoitetaan <code>int</code>-tyyppiseen muuttujaan aivan kuin mikä tahansa muukin int-arvo. Paluuarvo voi toimia myös osana mitä tahansa lauseketta:
</p>

<% partial 'partials/code_highlight' do %>
  public static void main(String[] args) {
      Opettaja opettaja = new Opettaja();

      double keskiarvo = (opettaja.arvostele() + opettaja.arvostele()) / 2.0;

      System.out.println("Arvostelujen keskiarvo " + keskiarvo);
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Arvostelujen keskiarvo 10.0
<% end %>

<p>
  Kaikki tähän mennessä näkemämme muuttujatyypit voidaan myös palauttaa metodista. Yhteenveto:
</p>

<ul>
  <li>Metodilla, joka ei palauta mitään, on <code>void</code>-määre palautettavan muuttujan tyyppinä.
    <% partial 'partials/code_highlight' do %>
      public void metodiJokaEiPalautaMitaan() {
          // metodin runko
      }
    <% end %>
  </li>

  <li>Metodilla, joka palauttaa kokonaislukutyyppisen muuttujan, on <code>int</code>-määre palautettavan muuttujan tyyppinä.
    <% partial 'partials/code_highlight' do %>
      public int metodiJokaPalauttaaKokonaisLuvun() {
          // metodin runko, tarvitsee return-komennon
      }
    <% end %>
  </li>


  <li>Metodilla, joka palauttaa merkkijonotyyppisen muuttujan, on <code>String</code>-määre palautettavan muuttujan tyyppinä.
    <% partial 'partials/code_highlight' do %>
      public String metodiJokaPalauttaaTekstin() {
          // metodin runko, tarvitsee return-komennon
      }
    <% end %>
  </li>
    
  <li>Metodilla, joka palauttaa liukulukutyyppisen muuttujan, on <code>double</code>-määre palautettavan muuttujan tyyppinä.
    <% partial 'partials/code_highlight' do %>
      public double metodiJokaPalauttaaLiukuluvun() {
          // metodin runko, tarvitsee return-komennon
      }
    <% end %>
  </li>
</ul>

<p>
  Jatketaan nyt henkilön parissa ja lisätään henkilölle iän palauttava metodi.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      // ...

      public int palautaIka() {
          return this.ika;
      }
  }
<% end %>

<p>
  Luokka kokonaisuudessaan:
</p>

<p>
  <img src="/img/diagrams/luokkakaavio-henkilo-ika-ja-nimi-ja-konstruktori-ja-tulosta-ja-vanhene-ja-palautaika.png" alt="[Henkilo|-nimi:String;-ika:int|+Henkilo(String);+tulostaHenkilo():void;+vanhene():void;+palautaIka():int]">
</p>

<p>
  Havainnollistetaan metodin toimintaa:
</p>

<% partial 'partials/code_highlight' do %>
  public class Main {

      public static void main(String[] args) {
          Henkilo pekka = new Henkilo("Pekka");
          Henkilo antti = new Henkilo("Antti");

          pekka.vanhene();
          pekka.vanhene();

          antti.vanhene();

          System.out.println("Pekan ikä: " + pekka.palautaIka());
          System.out.println("Antin ikä: " + antti.palautaIka());

          int yht = pekka.palautaIka() + antti.palautaIka();

          System.out.println("Pekka ja Antti yhteensä " + yht + " vuotta");
      }
  }
<% end %>


<% partial 'partials/sample_output' do %>
  Pekan ikä 2
  Antin ikä 1

  Pekka ja Antti yhteensä 3 vuotta
<% end %>


<%= partial 'partials/quiz', locals: { id: '59bd00596ee1930004e5f921' } %>

<%= partial 'partials/quiz', locals: { id: '5a57bcce574f0b000439a331' } %>

<% partial 'partials/exercise', locals: { name: 'Henkilön toteutus' } do %>
  
  <p>
    Seuraa materiaalin tähänastista esimerkkiä ja luo luokka Henkilo. Henkilön tulee sisältää seuraavan luokkakaavion määrittelemät ominaisuudet edellä mainittujen esimerkkien mukaisesti.
  </p>

  <p>
    <img src="/img/diagrams/luokkakaavio-henkilo-ika-ja-nimi-ja-konstruktori-ja-tulosta-ja-vanhene-ja-palautaika.png">
  </p>

  <% partial 'partials/code_highlight' do %>
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo antti = new Henkilo("Antti");

    antti.tulostaHenkilo();

    pekka.vanhene();
    pekka.vanhene();

    antti.vanhene();

    System.out.println("Pekan ikä: " + pekka.palautaIka());
    System.out.println("Antin ikä: " + antti.palautaIka());

    int yht = pekka.palautaIka() + antti.palautaIka();

    System.out.println("Pekka ja Antti yhteensä " + yht + " vuotta");
  <% end %>

  <% partial 'partials/sample_output' do %>
    Antti, ikä 0 vuotta
    Pekan ikä 2
    Antin ikä 1

    Pekka ja Antti yhteensä 3 vuotta
  <% end %>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Musiikkikappale' } do %>

  <p>
    Luo luokka nimeltä <code>Musiikkikappale</code>. Musiikkikappaleella on oliomuuttujat <code>nimi</code> (merkkijono) ja <code>pituus</code> sekunteina (kokonaisluku). Molemmat asetetaan konstruktorissa <code>public Musiikkikappale(String kappaleenNimi, int kappaleenPituus)</code>. Lisää oliolle myös metodit <code>public String nimi()</code>, joka palauttaa kappaleen nimen, ja <code>public int pituus()</code>, joka palauttaa kappaleen pituuden.
  </p>

  <p>
    Luokan tulee toimia seuraavasti.
  </p>

  <% partial 'partials/code_highlight' do %>
    Musiikkikappale garden = new Musiikkikappale("In The Garden", 10910);
    System.out.println("Kappaleen " + garden.nimi() + " pituus on " + garden.pituus() + " sekuntia.");
  <% end %>

  <% partial 'partials/sample_output' do %>
    Kappaleen In The Garden pituus on 10910 sekuntia.
  <% end %>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Metodien sisäinen toiminnallisuus
<% end %>

<p>
  Kuten aiemmin huomasimme, metodit sisältävät lähdekoodia aivan samalla tavalla kuin muutkin ohjelmamme osat. Metodeissa voi olla ehtolauseita tai toistolauseita, ja metodeista voi kutsua myös muita metodeja.
</p>

<p>
  Tehdään seuraavaksi henkilölle metodi, jonka avulla voidaan selvittää onko henkilö täysi-ikäinen. Metodi palauttaa totuusarvon -- joko <code>true</code> tai <code>false</code>:
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      // ...

      public boolean taysiIkainen() {
          if (this.ika &lt; 18) {
              return false;
          }

          return true;
      }

      /*
      huom. metodin voisi kirjoittaa lyhyemmin seuraavasti:

      public boolean taysiIkainen() {
          return this.ika >= 18;
      }
      */
  }
<% end %>

<p>
  Ja testataan:
</p>

<% partial 'partials/code_highlight' do %>
  public static void main(String[] args) {
      Henkilo pekka = new Henkilo("Pekka");
      Henkilo antti = new Henkilo("Antti");

      int i = 0;
      while (i &lt; 30) {
          pekka.vanhene();
          i++;
      }

      antti.vanhene();

      System.out.println("");

      if (antti.taysiIkainen()) {
          System.out.print("täysi-ikäinen: ");
          antti.tulostaHenkilo();
      } else {
          System.out.print("alaikäinen: ");
          antti.tulostaHenkilo();
      }

      if (pekka.taysiIkainen()) {
          System.out.print("täysi-ikäinen: ");
          pekka.tulostaHenkilo();
      } else {
          System.out.print("alaikäinen: ");
          pekka.tulostaHenkilo();
      }
  }
<% end %>

<% partial 'partials/sample_output' do %>
  alaikäinen: Antti, ikä 1 vuotta
  täysi-ikäinen: Pekka, ikä 30 vuotta
<% end %>

<p>
  Viritellään ratkaisua vielä hiukan. Nyt henkilön pystyy "tulostamaan" ainoastaan siten, että nimen lisäksi tulostuu ikä. On tilanteita, joissa haluamme tietoon pelkän olion nimen. Eli tehdään tarkoitusta varten oma metodi:
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      // ...

      public String getNimi() {
          return this.nimi;
      }
  }
<% end %>

<p>
  Metodi <code>getNimi</code> palauttaa oliomuuttujan <code>nimi</code> kutsujalle. Metodin nimi on hieman erikoinen. Javassa on usein tapana nimetä oliomuuttujan palauttava metodi juuri näin, eli <code>getMuuttujanNimi</code>. Tälläisiä metodeja kutsutaan usein "gettereiksi".
</p>

<p>
  Luokka kokonaisuudessaan:
</p>

<p>
  <img src="/img/diagrams/luokkakaavio-henkilo-getterit.png" alt="[Henkilo|-nimi:String;-ika:int|+Henkilo(String);+tulostaHenkilo():void;+vanhene():void;+palautaIka():int;+taysiIkainen():boolean;+getNimi():String]">
</p>

<p>
  Muotoillaan pääohjelma käyttämään uutta "getteri"-metodia:
</p>

<% partial 'partials/code_highlight' do %>
  public static void main(String[] args) {
      Henkilo pekka = new Henkilo("Pekka");
      Henkilo antti = new Henkilo("Antti");

      int i = 0;
      while (i &lt; 30) {
          pekka.vanhene();
          i++;
      }

      antti.vanhene();

      System.out.println("");

      if (antti.taysiIkainen()) {
          System.out.println(antti.getNimi() + " on täysi-ikäinen");
      } else {
          System.out.println(antti.getNimi() + " on alaikäinen");
      }

      if (pekka.taysiIkainen()) {
          System.out.println(pekka.getNimi() + " on täysi-ikäinen");
      } else {
          System.out.println(pekka.getNimi() + " on alaikäinen ");
      }
  }
<% end %>

<p>
  Tulostus alkaa olla jo aika siisti:
</p>

<% partial 'partials/sample_output' do %>
  Antti on alaikäinen
  Pekka on täysi-ikäinen
<% end %>


<% partial 'partials/exercise', locals: { name: 'Elokuva' } do %>
  <p>
    Luo luokka Elokuva, jolla on oliomuuttujat <code>nimi</code> (String) ja <code>ikaraja</code> (int). Tee luokalle konstruktori <code>public Elokuva(String elokuvanNimi, int elokuvanIkaraja)</code> sekä metodit <code>public String nimi()</code> ja <code>public int ikaraja()</code>. Ensimmäinen palauttaa elokuvan nimen ja toinen elokuvan ikärajan.
  </p>

  <p>
    Esimerkki luokan toiminnasta.
  </p>

  <% partial 'partials/code_highlight' do %>
    Elokuva chipmunks = new Elokuva("Alvin and the Chipmunks: The Squeakquel", 0);

    Scanner lukija = new Scanner(System.in);

    System.out.println("Minkä ikäinen olet?");
    int ika = Integer.parseInt(lukija.nextLine());

    System.out.println();
    if (ika &gt;= chipmunks.ikaraja()) {
        System.out.println("Saat katsoa elokuvan " + chipmunks.nimi());
    } else {
        System.out.println("Et saa katsoa elokuvaa " + chipmunks.nimi());
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    Minkä ikäinen olet?
    <font color="red">7</font>

    Saat katsoa elokuvan Alvin and the Chipmunks: The Squeakquel
  <% end %>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Olion merkkijonoesitys ja toString-metodi
<% end %>

<p>
  Olemme syyllistyneet osittain huonoon ohjelmointityyliin tekemällä metodin jonka avulla olio tulostetaan, eli metodin <code>tulostaHenkilo</code>. Suositeltavampi tapa on määritellä oliolle metodi jonka palauttaa olion "merkkijonoesityksen". Merkkijonoesityksen palauttavan metodin nimi on Javassa aina <code>toString</code>. Määritellään seuraavassa henkilölle tämä metodi:
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      // ...

      public String toString() {
          return this.nimi + ", ikä " + this.ika + " vuotta";
      }
  }
<% end %>

<p>
  Metodi <code>toString</code> toimii kuten <code>tulostaHenkilo</code>, mutta se ei itse tulosta mitään vaan palauttaa merkkijonoesityksen, jota metodin kutsuja voi halutessaan suorittaa tulostamisen.
</p>

<p>
  Metodia käytetään hieman yllättävällä tavalla:
</p>

<% partial 'partials/code_highlight' do %>
  public static void main(String[] args) {
      Henkilo pekka = new Henkilo("Pekka");
      Henkilo antti = new Henkilo("Antti");

      int i = 0;
      while (i &lt; 30) {
          pekka.vanhene();
          i++;
      }

      antti.vanhene();

      System.out.println(antti); // sama kun System.out.println(antti.toString());
      System.out.println(pekka); // sama kun System.out.println(pekka.toString());
  }
<% end %>


<p>
  Periaatteena on, että <code>System.out.println</code>-metodi pyytää olion merkkijonoesityksen ja tulostaa sen. Merkkijonoesityksen palauttavan <code>toString</code>-metodin kutsua ei tarvitse kirjoittaa itse, sillä Java lisää sen automaattisesti. Ohjelmoijan kirjoittaessa:
</p>

<% partial 'partials/code_highlight' do %>
  System.out.println(antti);
<% end %>

<p>
  Java täydentää suorituksen aikana kutsun muotoon:
</p>

<% partial 'partials/code_highlight' do %>
  System.out.println(antti.toString());
<% end %>

<p>
  Käy niin, että oliolta pyydetään sen merkkijonoesitys. Olion palauttama merkkijonoesitys tulostetaan normaaliin tapaan <code>System.out.println</code>-komennolla.
</p>

<p>
  <b>Voimme nyt poistaa turhaksi käyneen <code>tulostaHenkilo</code>-metodin.</b>
</p>

<p>
  Olioscreencastin toinen osa:
</p>

<a href="http://www.youtube.com/watch?feature=player_embedded&v=d-56AxspStE" class="youtube" height="300" target="_blank" rel="noopener"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

<!--
     <p><iframe allowfullscreen="" frameborder="0" height="450" width="700" src="http://www.youtube.com/embed/eX7XXP5GHTk"></iframe></p>
   -->

<p>&nbsp;</p>

<% partial 'partials/exercise', locals: { name: 'Agentti' } do %>

  <p>
    Tehtäväpohjassa on määriteltynä luokka Agentti, jolla on etunimi ja sukunimi. Luokalle on määritelty metodi <code>tulosta</code>, joka luo seuraavanlaisen merkkijonoesityksen.
  </p>

  <% partial 'partials/code_highlight' do %>
    Agentti bond = new Agentti("James", "Bond");
    bond.tulosta();
  <% end %>

  <% partial 'partials/sample_output' do %>
    My name is Bond, James Bond
  <% end %>

  <p>
    Poista luokan metodi <code>tulosta</code> ja luo luokalle metodi <code>public String toString()</code>, joka palauttaa edellämainitun merkkijonoesityksen.
  </p>

  <p>
    Luokan tulee toimia jatkossa seuraavasti.
  </p>

  <% partial 'partials/code_highlight' do %>
    Agentti bond = new Agentti("James", "Bond");

    bond.toString(); // ei tulosta mitään
    System.out.println(bond);

    Agentti ionic = new Agentti("Ionic", "Bond");
    System.out.println(ionic);
  <% end %>

  <% partial 'partials/sample_output' do %>
    My name is Bond, James Bond
    My name is Bond, Ionic Bond
  <% end %>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Maksukortti (6 osaa)' } do %>

  <p>
    Helsingin Yliopiston opiskelijaruokaloissa eli Unicafeissa opiskelijat maksavat lounaansa käyttäen maksukorttia. Lopullinen Maksukortti tulee näyttämään luokkakaaviona seuraavalta:
  </p>

  <p>
    <img src="/img/diagrams/luokkakaavio-teht-maksukortti.png" alt="[Maksukortti|-saldo:double|+Maksukortti(double);+syoEdullisesti():void;+syoMaukkaasti():void;+lataaRahaa(double):void;+toString():String]">
  </p>

  <p>
    Tässä tehtäväsäsarjassa tehdään luokka <code>Maksukortti</code>, jonka tarkoituksena on jäljitellä Unicafeissa tapahtuvaa maksutoimintaa.
  </p>

  <h2>Luokan runko</h2>

  <p>
    Projektiin tulee kuulumaan kaksi kooditiedostoa:
  </p>

  <p>
    Tehtäväpohjan mukana tulee kooditiedosto <code>Paaohjelma</code> jonka sisällä on <code>main</code>-metodi.
  </p>

  <p>
    Lisää projektiin uusi luokka nimeltä <code>Maksukortti</code>. Uuden luokan saa lisättyä seuraavasti: Ruudun vasemmalla reunalla on projektilistaus. Paina projektin nimen kohdalla hiiren oikeaa nappia. Valitse avautuvasta valikosta <em>New</em> ja <em>Java Class</em>. Anna luokan nimeksi (Class Name) <code>Maksukortti</code>.
  </p>

  <p>
    Tee ensin <code>Maksukortti</code>-olion konstruktori, jolle annetaan kortin alkusaldo ja joka tallentaa sen olion sisäiseen muuttujaan. Tee sitten <code>toString</code>-metodi, joka palauttaa kortin saldon muodossa "Kortilla on rahaa X euroa".
  </p>

  <p>
    Seuraavassa on luokan <code>Maksukortti</code> runko:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Maksukortti {
        private double saldo;

        public Maksukortti(double alkusaldo) {
            // kirjoita koodia tähän
        }

        public String toString() {
            // kirjoita koodia tähän
        }
    }
  <% end %>

  <p>
    Seuraava pääohjelma testaa luokkaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            Maksukortti kortti = new Maksukortti(50);
            System.out.println(kortti);
        }
    }
  <% end %>


  <p>
    Ohjelman tulisi tuottaa seuraava tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
    Kortilla on rahaa 50.0 euroa
  <% end %>


  <h2>Kortilla maksaminen</h2>

  <p>
    Täydennä <code>Maksukortti</code>-luokkaa seuraavilla metodeilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    public void syoEdullisesti() {
        // kirjoita koodia tähän
    }

    public void syoMaukkaasti() {
        // kirjoita koodia tähän
    }
  <% end %>

  <p>
    Metodin <code>syoEdullisesti</code> tulisi vähentää kortin saldoa 2.60 eurolla ja metodin <code>syoMaukkaasti</code> tulisi vähentää kortin saldoa 4.60 eurolla.
  </p>

  <p>
    Seuraava pääohjelma testaa luokkaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            Maksukortti kortti = new Maksukortti(50);
            System.out.println(kortti);

            kortti.syoEdullisesti();
            System.out.println(kortti);

            kortti.syoMaukkaasti();
            kortti.syoEdullisesti();
            System.out.println(kortti);
        }
    }
  <% end %>

  <p>
    Ohjelman tulisi tuottaa kutakuinkin seuraava tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
    Kortilla on rahaa 50.0 euroa
    Kortilla on rahaa 47.4 euroa
    Kortilla on rahaa 40.199999999999996 euroa
  <% end %>


  <h2>Ei-negatiivinen saldo</h2>

  <p>
    Mitä tapahtuu, jos kortilta loppuu raha kesken? Ei ole järkevää, että saldo muuttuu negatiiviseksi. Muuta metodeita <code>syoEdullisesti</code> ja <code>syoMaukkaasti</code> niin, että ne eivät vähennä saldoa, jos saldo menisi negatiiviseksi.
  </p>

  <p>
    Seuraava pääohjelma testaa luokkaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            Maksukortti kortti = new Maksukortti(5);
            System.out.println(kortti);

            kortti.syoMaukkaasti();
            System.out.println(kortti);

            kortti.syoMaukkaasti();
            System.out.println(kortti);
        }
    }
  <% end %>

  <p>
    Ohjelman tulisi tuottaa seuraava tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
    Kortilla on rahaa 5.0 euroa
    Kortilla on rahaa 0.40000000000000036
    Kortilla on rahaa 0.40000000000000036
  <% end %>


  <p>
    Yllä toinen metodin <code>syoMaukkaasti</code> kutsu ei vaikuttanut saldoon, koska saldo olisi mennyt negatiiviseksi.
  </p>

  <h2>Kortin lataaminen</h2>

  <p>
    Lisää <code>Maksukortti</code>-luokkaan seuraava metodi:
  </p>

  <% partial 'partials/code_highlight' do %>
    public void lataaRahaa(double rahamaara) {
        // kirjoita koodia tähän
    }
  <% end %>

  <p>
    Metodin tarkoituksena on kasvattaa kortin saldoa parametrina annetulla rahamäärällä. Kuitenkin kortin saldo saa olla korkeintaan 150 euroa, joten jos ladattava rahamäärä ylittäisi sen, saldoksi tulisi tulla silti tasan 150 euroa.
  </p>

  <p>
    Seuraava pääohjelma testaa luokkaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            Maksukortti kortti = new Maksukortti(10);
            System.out.println(kortti);

            kortti.lataaRahaa(15);
            System.out.println(kortti);

            kortti.lataaRahaa(10);
            System.out.println(kortti);

            kortti.lataaRahaa(200);
            System.out.println(kortti);
        }
    }
  <% end %>

  <p>
    Ohjelman tulisi tuottaa seuraava tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
    Kortilla on rahaa 10.0 euroa
    Kortilla on rahaa 25.0 euroa
    Kortilla on rahaa 35.0 euroa
    Kortilla on rahaa 150.0 euroa
  <% end %>


  <h2>Kortin lataus negatiivisella arvolla</h2>

  <p>
    Muuta metodia <code>lataaRahaa</code> vielä siten, että jos yritetään ladata negatiivinen rahamäärä, ei kortilla oleva arvo muutu.
  </p>

  <p>
    Seuraava pääohjelma testaa luokkaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            Maksukortti kortti = new Maksukortti(10);
            System.out.println("Pekka: " + kortti);
            kortti.lataaRahaa(-15);
            System.out.println("Pekka: " + kortti);
        }
    }
  <% end %>

  <p>
    Ohjelman tulisi tuottaa seuraava tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
    Pekka: Kortilla on rahaa 10.0 euroa
    Pekka: Kortilla on rahaa 10.0 euroa
  <% end %>


  <h2>Monta korttia</h2>

  <p>
    Tee pääohjelma, joka sisältää seuraavan tapahtumasarjan:
  </p>

  <ul>
    <li> Luo Pekan kortti. Kortin alkusaldo on 20 euroa</li>
    <li> Luo Matin kortti. Kortin alkusaldo on 30 euroa</li>
    <li> Pekka syö maukkaasti</li>
    <li> Matti syö edullisesti</li>
    <li> Korttien arvot tulostetaan (molemmat omalle rivilleen, rivin alkuun kortin omistajan nimi)</li>
    <li> Pekka lataa rahaa 20 euroa</li>
    <li> Matti syö maukkaasti</li>
    <li> Korttien arvot tulostetaan (molemmat omalle rivilleen, rivin alkuun kortin omistajan nimi)</li>
    <li> Pekka syö edullisesti</li>
    <li> Pekka syö edullisesti</li>
    <li> Matti lataa rahaa 50 euroa</li>
    <li> Korttien arvot tulostetaan (molemmat omalle rivilleen, rivin alkuun kortin omistajan nimi)</li>
  </ul>

  <p>
    Pääohjelman runko on seuraava:
  </p>


  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Maksukortti pekanKortti = new Maksukortti(20);
            Maksukortti matinKortti = new Maksukortti(30);

            // kirjoita koodia tähän
        }
    }
  <% end %>

  <p>
    Ohjelman tulisi tuottaa seuraava tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
    Pekka: Kortilla on rahaa 15.4 euroa
    Matti: Kortilla on rahaa 27.4 euroa
    Pekka: Kortilla on rahaa 35.4 euroa
    Matti: Kortilla on rahaa 22.799999999999997 euroa
    Pekka: Kortilla on rahaa 30.199999999999996 euroa
    Matti: Kortilla on rahaa 72.8 euroa
  <% end %>


<% end %>



<% partial 'partials/hint', locals: { name: 'Pyöristysvirheet' } do %>

  <p>
    Huomasit todennäköisesti, että osassa luvuista ilmenee pyöristysvirheitä. Esimerkiksi edellisessä tehtävässä Pekan saldo 30.7 saattaa tulostua muodossa <code>30.700000000000003</code>. Tämä liittyy siihen, että liukuluvut kuten <code>double</code> tallennetaan oikeasti binäärimuodossa, eli nollina ja ykkösinä vain rajattua määrää lukuja käyttäen.
  </p>

  <p>
    Koska liukulukuja on ääretön määrä (keksitkö miksi? kuinka monta liuku- tai desimaalilukua mahtuu vaikkapa lukujen 5 ja 6 väliin?), ei kaikkia liukulukuja yksinkertaisesti voi esittää rajatulla määrällä nollia ja ykkösiä. Tietokone joutuu siis rajoittamaan tallennustarkkuutta.
  </p>

  <p>
    Normaalisti esimerkiksi tilien saldot tallennetaan kokonaislukuina siten, että arvo 1 vastaa esimerkiksi yhtä senttiä.
  </p>
<% end %>




<% partial 'partials/material_sub_heading' do %>
  Metodin parametrit
<% end %>


<p>
  Jatketaan taas <code>Henkilo</code>-luokan parissa. Päätetään että haluamme laskea henkilöiden painoindeksejä. Tätä varten teemme henkilölle metodit pituuden ja painon asettamista varten, sekä metodin joka laskee painoindeksin. Henkilön uudet ja muuttuneet osat seuraavassa:
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      private String nimi;
      private int ika;
      private int paino;
      private int pituus;

      public Henkilo(String nimiAlussa) {
          this.ika = 0;
          this.paino = 0;
          this.pituus = 0;
          this.nimi = nimiAlussa;
      }

      public void setPituus(int uusiPituus) {
          this.pituus = uusiPituus;
      }

      public void setPaino(int uusiPaino) {
          this.paino = uusiPaino;
      }

      public double painoIndeksi() {
          double pituusPerSata = this.pituus / 100.0;
          return this.paino / (pituusPerSata * pituusPerSata);
      }

      // ...
  }
<% end %>

<p>
  Eli henkilölle lisättiin oliomuuttujat <code>pituus</code> ja <code>paino</code>. Näille voi asettaa arvon metodeilla <code>setPituus</code> ja <code>setPaino</code>. Jälleen käytössä Javaan vakiintunut nimeämiskäytäntö, eli jos metodin tehtävänä on ainoastaan asettaa arvo oliomuuttujaan, on metodi tapana nimetä <code>setMuuttujanNimi</code>:ksi. Arvon asettavia metodeja kutsutaan usein "settereiksi". Seuraavassa käytämme uusia metodeja:
</p>

<% partial 'partials/code_highlight' do %>
  public static void main(String[] args) {
      Henkilo matti = new Henkilo("Matti");
      Henkilo juhana = new Henkilo("Juhana");

      matti.setPituus(180);
      matti.setPaino(86);

      juhana.setPituus(175);
      juhana.setPaino(64);

      System.out.println(matti.getNimi() + ", painoindeksisi on " + matti.painoIndeksi());
      System.out.println(juhana.getNimi() + ", painoindeksisi on " + juhana.painoIndeksi());
  }
<% end %>

<p>
  Tulostus:
</p>

<% partial 'partials/sample_output' do %>
  Matti, painoindeksisi on 26.54320987654321
  Juhana, painoindeksisi on 20.897959183673468
<% end %>



<% partial 'partials/material_sub_heading' do %>
  Parametrilla ja oliomuuttujalla sama nimi!
<% end %>

<p>
  Edellä metodissa <code>setPituus</code> asetetaan oliomuuttujaan <code>pituus</code> parametrin <code>uusiPituus</code> arvo:
</p>


<% partial 'partials/code_highlight' do %>
  public void setPituus(int uusiPituus) {
      this.pituus = uusiPituus;
  }
<% end %>

<p>
  Parametrin nimi voisi olla myös sama kuin oliomuuttujan nimi, eli seuraava toimisi myös:
</p>

<% partial 'partials/code_highlight' do %>
  public void setPituus(int pituus) {
      this.pituus = pituus;
  }
<% end %>

<p>
  Nyt metodissa <code>pituus</code> tarkottaa nimenomaan <em>pituus</em>-nimistä parametria ja <code>this.pituus</code> saman nimistä oliomuuttujaa. Esim. seuraava ei toimisi sillä koodi ei viittaa ollenkaan oliomuuttujaan <em>pituus</em> -- koodi käytännössä asettaa parametrina saadulle <code>pituus</code>-muuttujalle siinä jo olevan arvon:
</p>

<% partial 'partials/code_highlight' do %>
  public void setPituus(int pituus) {
      // ÄLÄ TEE NÄIN!!!
      pituus = pituus;
  }
<% end %>

<% partial 'partials/code_highlight' do %>
  public void setPituus(int pituus) {
      // VAAN NÄIN!!!
      this.pituus = pituus;
  }
<% end %>



<% partial 'partials/exercise', locals: { name: 'Kertoja' } do %>

  <p>
    Luo luokka <code>Kertoja</code> jolla on:
  </p>

  <ul>
    <li>Konstruktori <code>public Kertoja(int luku)</code>.</li>
    <li>Metodi <code>public int kerro(int luku)</code> joka palauttaa sille annetun luvun <code>luku</code> kerrottuna konstruktorille annetulla luvulla <code>luku</code>.</li>
  </ul>

  <p>
    Tarvinnet tässä myös oliomuuttujan...
  </p>

  <p>
    Esimerkki luokan käytöstä:
  </p>

  <% partial 'partials/code_highlight' do %>
    Kertoja kolmellaKertoja = new Kertoja(3);

    System.out.println("kolmellaKertoja.kerro(2): " + kolmellaKertoja.kerro(2));

    Kertoja neljallaKertoja = new Kertoja(4);

    System.out.println("neljallaKertoja.kerro(2): " + neljallaKertoja.kerro(2));
    System.out.println("kolmellaKertoja.kerro(1): " + kolmellaKertoja.kerro(1));
    System.out.println("neljallaKertoja.kerro(1): " + neljallaKertoja.kerro(1));
  <% end %>

  <p>
    Tulostus
  </p>

  <% partial 'partials/sample_output' do %>
    kolmellaKertoja.kerro(2): 6
    neljallaKertoja.kerro(2): 8
    kolmellaKertoja.kerro(1): 3
    neljallaKertoja.kerro(1): 4
  <% end %>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Oman metodin kutsu
<% end %>

<p>
  Olio voi kutsua myös omia metodeitaan. Jos esim. halutaan, että toString-metodin palauttama merkkijonoesitys kertoisi myös henkilön painoindeksin, kannattaa <code>toString</code>:istä kutsua olion omaa metodia <code>painoIndeksi</code>:
</p>

<% partial 'partials/code_highlight' do %>
  public String toString() {
      return this.nimi + ", ikä " + this.ika + " vuotta, painoindeksini on " + this.painoIndeksi();
  }
<% end %>

<p>
  Eli kun olio kutsuu omaa metodiaan, riittää etuliite this ja pelkkä metodin nimi. Vaihtoehtoinen tapa on tehdä oman metodin kutsu muodossa <code>painoIndeksi()</code> jolloin ei korosteta, että kutsutaan "olion itsensä" metodia painoindeksi:
</p>

<% partial 'partials/code_highlight' do %>
  public String toString() {
  return this.nimi + ", ikä " + this.ika + " vuotta, painoindeksini on " + painoIndeksi();
  }
<% end %>

<p>
  Olioscreencastin kolmas osa:
</p>

<a href="http://www.youtube.com/watch?feature=player_embedded&v=YKwzIGuCLn8" class="youtube" height="300" target="_blank" rel="noopener"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>


<p>
  &nbsp;
</p>

<% partial 'partials/exercise', locals: { name: 'Lukutilasto (4 osaa)' } do %>

  <h2>Lukujen määrä</h2>

  <p>
    Tee luokka <code>Lukutilasto</code> (tiedosto luomaasi luokkaa varten on tehtäväpohjassa valmiina), joka tuntee seuraavat toiminnot:
  </p>

  <ul>
    <li> metodi <code>lisaaLuku</code> lisää uuden luvun tilastoon</li>
    <li> metodi <code>haeLukujenMaara</code> kertoo lisättyjen lukujen määrän</li>
  </ul>

  <p>
    Luokan ei tarvitse tallentaa mihinkään lisättyjä lukuja, vaan riittää muistaa niiden määrä. Metodin <code>lisaaLuku</code> ei tässä vaiheessa tarvitse edes ottaa huomioon, mikä luku lisätään tilastoon, koska ainoa tallennettava asia on lukujen määrä.
  </p>

  <p>
    Luokan runko on seuraava:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Lukutilasto {
        private int lukujenMaara;

        public Lukutilasto() {
            // alusta tässä muuttuja lukujenMaara
        }

        public void lisaaLuku(int luku) {
            // kirjoita koodia tähän
        }

        public int haeLukujenMaara() {
            // kirjoita koodia tähän
        }
    }
  <% end %>

  <p>
    Seuraava ohjelma esittelee luokan käyttöä:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            Lukutilasto tilasto = new Lukutilasto();
            tilasto.lisaaLuku(3);
            tilasto.lisaaLuku(5);
            tilasto.lisaaLuku(1);
            tilasto.lisaaLuku(2);
            System.out.println("Määrä: " + tilasto.haeLukujenMaara());
        }
    }
  <% end %>

  <p>
    Ohjelman tulostus on seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Määrä: 4
  <% end %>
  
  
  <h2>Summa ja keskiarvo</h2>
  
  <p>
    Laajenna luokkaa seuraavilla toiminnoilla:
  </p>

  <ul>
    <li> metodi <code>summa</code> kertoo lisättyjen lukujen summan (tyhjän lukutilaston summa on 0)</li>
    <li> metodi <code>keskiarvo</code> kertoo lisättyjen lukujen keskiarvon (tyhjän lukutilaston keskiarvo on 0)</li>
  </ul>

  <p>
    Luokan runko on seuraava:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Lukutilasto {
        private int lukujenMaara;
        private int summa;

        public Lukutilasto() {
            // alusta tässä muuttujat maara ja summa
        }

        public void lisaaLuku(int luku) {
            // kirjoita koodia tähän
        }

        public int haeLukujenMaara() {
            // kirjoita koodia tähän
        }

        public int summa() {
            // kirjoita koodia tähän
        }

        public double keskiarvo() {
            // kirjoita koodia tähän
        }
    }
  <% end %>

  <p>
    Seuraava ohjelma esittelee luokan käyttöä:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Lukutilasto tilasto = new Lukutilasto();
            tilasto.lisaaLuku(3);
            tilasto.lisaaLuku(5);
            tilasto.lisaaLuku(1);
            tilasto.lisaaLuku(2);
            System.out.println("Määrä: " + tilasto.haeLukujenMaara());
            System.out.println("Summa: " + tilasto.summa());
            System.out.println("Keskiarvo: " + tilasto.keskiarvo());
        }
    }
  <% end %>

  <p>
    Ohjelman tulostus on seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Määrä: 4
    Summa: 11
    Keskiarvo: 2.75
  <% end %>


  <h2>Summa käyttäjältä</h2>

  <p>
    Tee ohjelma, joka kysyy lukuja käyttäjältä, kunnes käyttäjä antaa luvun -1. Sitten ohjelma ilmoittaa lukujen summan.
  </p>

  <p>
    Ohjelmassa tulee käyttää <code>Lukutilasto</code>-olioa summan laskemiseen.
  </p>

  <p>
    <strong>HUOM: </strong> älä muuta Lukutilasto-luokkaa millään tavalla!
  </p>

  <% partial 'partials/sample_output' do %>
    Anna lukuja:
    <font color="red">4</font>
    <font color="red">2</font>
    <font color="red">5</font>
    <font color="red">4</font>
    <font color="red">-1</font>
    Summa: 15
  <% end %>

  
  <h2>Monta summaa</h2>
  
  <p>
    Muuta edellistä ohjelmaa niin, että ohjelma laskee myös parillisten ja parittomien lukujen summaa.
  </p>

  <p>
    <b>HUOM</b>: Määrittele ohjelmassa <i>kolme</i> Lukutilasto-olioa ja laske ensimmäisen avulla kaikkien lukujen summa, toisen avulla parillisten lukujen summa ja kolmannen avulla parittomien lukujen summa.
  </p>

  <p>
    <b>Jotta testi toimisi, on oliot luotava pääohjelmassa edellä mainitussa järjestyksessä (eli ensin kaikkien summan laskeva olio, toisena parillisten summan laskeva ja viimeisenä parittomien summan laskeva olio)!</b>
  </p>

  <p>
    <strong>HUOM: </strong> älä muuta Lukutilasto-luokaa millään tavalla!
  </p>

  <p>
    Ohjelman tulee toimia seuraavasti:
  </p>

  <% partial 'partials/sample_output' do %>
    Anna lukuja:
    <font color="red">4</font>
    <font color="red">2</font>
    <font color="red">5</font>
    <font color="red">2</font>
    <font color="red">-1</font>
    Summa: 13
    Parillisten summa: 8
    Parittomien summa: 5
  <% end %>

<% end %>




<% partial 'partials/material_sub_heading' do %>
  Mistä olio-ohjelmoinnissa oikein on kyse: katsaus taaksepäin
<% end %>

<p>
  Olio-ohjelmoinnissa on kyse pitkälti käsitteiden eristämisestä omiksi kokonaisuuksikseen tai toisin ajatellen abstraktioiden muodostamisesta. Voisi ajatella, että on turhaa luoda oliota jonka sisällä on ainoastaan luku, sillä saman voisi tehdä suoraan <code>int</code>-muuttujilla. Asia ei kuitenkaan ole aina näin. Jos kello koostuu pelkästään kolmesta int-muuttujasta joita kasvatellaan, muuttuu ohjelma lukijan kannalta epäselvemmäksi, koodista on vaikea "nähdä" mistä on kysymys. Eräs <a href="https://en.wikipedia.org/wiki/Kent_Beck" target="_blank" rel="noopener">kuuluisa ohjelmoija</a> on sanonut <em>"Any fool can write code that a computer can understand.  Good programmers write code that humans can understand"</em>. Koska viisari on oma selkeä käsitteensä, kannattaa ohjelman ymmärrettävyyden parantamiseksi siitä tehdä oma luokka.
</p>

<p>
  Käsitteen erottaminen omaksi luokaksi on monellakin tapaa hyvä idea. Ensinnäkin tiettyjä yksityiskohtia (esim. laskurin pyörähtäminen) saadaan piilotettua luokan sisään (eli <em>abstrahoitua</em>). Sen sijaan että kirjoitetaan if-lause ja sijoitusoperaatio, riittää, että laskurin käyttäjä kutsuu selkeästi nimettyä metodia <code>seuraava()</code>. Aikaansaatu laskuri sopii kellon lisäksi ehkä muidenkin ohjelmien rakennuspalikaksi, eli selkeästä käsitteestä tehty luokka voi olla monikäyttöinen. Suuri etu saavutetaan myös sillä, että koska laskurin toteutuksen yksityiskohdat eivät näy laskurin käyttäjille, voidaan yksityiskohtia tarvittaessa muuttaa.
</p>

<p>
  Totesimme että kello sisältää kolme viisaria, eli koostuu kolmesta käsitteestä. Oikeastaan kello on itsekin käsite. Seuraavassa osiossa teemme myös luokan Kello, jotta voimme luoda selkeitä Kello-olioita. Kello tulee siis olemaan olio jonka toiminta perustuu "yksinkertaisimpiin" olioihin eli viisareihin. Tämä on juuri olio-ohjelmoinnin suuri idea: ohjelma rakennetaan pienistä selkeistä yhteistoiminnassa olevista olioista.
</p>

<p>
  Lausahdus <em>ohjelma rakennetaan pienistä selkeistä yhteistoiminnassa olevista olioista</em> tulee toistumaan kurssilla. 
</p>

<p>
  Nyt termistökin saattaa tuntua jo tutummalta..
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Olio
<% end %>

<p>
  <strong>Olio</strong> on itsenäinen kokonaisuus, johon liittyy tietoa (oliomuuttujat) sekä käyttäytymistä (metodit). Oliot voivat olla hyvin erilaisia rakenteeltaan ja toiminnaltaan: jotkut voivat kuvata ongelma-alueen käsitteitä, ja jotkut voivat koordinoida olioiden välistä toimintaa. Olioiden kommunikointi tapahtuu metodikutsujen avulla -- metodikutsuilla sekä kysytään tietoa olioita että annetaan olioille käskyjä.
</p>

<p>
  Yleisesti ottaen jokaisella oliolla on selkeästi määritellyt rajat ja toiminnallisuudet, jonka lisäksi jokainen olio tietää vain niistä muista olioista, joita se tarvitsee tehtävänsä tekemiseen. Toisin sanoen, olio piilottaa oman sisäisen toimintansa ja tarjoaa pääsyn toiminnallisuuksiin selkeästi määriteltyjen metodien kautta. Tämän lisäksi olio on riippumaton niistä olioista, joita se ei tehtäväänsä tarvitse.
</p>

<p>
  Edellä käsiteltiin Henkilö-oliota, jota varten luotiin Henkilö-luokka. Kertauksen vuoksi on hyvä muistella luokan tehtävää: <strong>luokka</strong> sisältää olioiden tekemiseen tarvittavat rakennuspiirrustukset sekä määrittelee olioiden muuttujat ja metodit. Olio luodaan luokassa olevan konstruktorin perusteella.
</p>

<p>
  Henkilö-olioomme liittyi nimi, ikä, paino ja pituus sekä muutamia metodeja. Jos mietimme henkilö-oliomme rakennetta tarkemmin, keksisimme varmaankin lisää henkilöihin liittyviä muuttujia kuten henkilöturvatunnus, puhelinnumero, osoite ja silmien väri. Pitäydytään toistaiseksi kuitenkin edellä mainituissa muuttujissa.
</p>

<p>
  Olion käyttäytyminen määräytyy metodien avulla. Todellisuudessa henkilöt voivat tehdä hyvin monia erilaisia asioita, mutta henkilöitä käsittelevää sovellusta rakennettaessa henkilöön liittyvät toiminnallisuudet rakennetaan ongelma-alueen perusteella. Esimerkiksi elämänhallintaan tarkoitettu sovellus voisi pitää kirjaa edellä mainituista iästä, painosta ja pituudesta, sekä tarjota mahdollisuuden painoindeksin ja maksimisykkeen laskemiseen.
</p>

<p>
  Oliot tarjoavat tyypillisesti pääsyn myös niiden tilaan. <strong>Olion tila</strong> on sen oliomuuttujien arvo kullakin ajanhetkellä. 
</p>

<p>
  Java-ohjelmointikielellä Henkilö-olion, joka pitää kirjaa nimestä, iästä, painosta ja pituudesta, sekä tarjoaa mahdollisuuden painoindeksi ja maksimisykkeen laskemiseen näyttäisi esimerkiksi seuraavalta. Huomaa, että alla oleva esimerkki poikkeaa hieman edellä rakennetusta esimerkistä. Alla pituus ja paino ilmaistaan doubleina -- pituuden yksikkö on metri.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      private String nimi;
      private int ika;
      private double paino;
      private double pituus;

      public Henkilo(String nimi, int ika, double paino, double pituus) {
          this.nimi = nimi;
          this.ika = ika;
          this.paino = paino;
          this.pituus = pituus;
      }

      public double painoindeksi() {
          return this.paino / (this.pituus * this.pituus);
      }

      public double maksimisyke() {
          return 206.3 - (0.711 * this.ika);
      }

      public String toString() {
          return this.nimi + ", BMI: " + this.painoindeksi()
              + ", maksimisyke: " + this.maksimisyke();
      }
  }
<% end %>

<p>
  Annetun henkilön maksimisykkeen ja painoindeksin selvittäminen on suoraviivaista edellä kuvatun Henkilo-luokan avulla.
</p>

<% partial 'partials/code_highlight' do %>
  Scanner lukija = new Scanner(System.in);
  System.out.println("Mikä on nimesi?");
  String nimi = lukija.nextLine();
  System.out.println("Mikä on ikäsi?");
  int ika = Integer.parseInt(lukija.nextLine());
  System.out.println("Mikä on painosi?");
  double paino = Double.parseDouble(lukija.nextLine());
  System.out.println("Mikä on pituutesi?");
  double pituus = Double.parseDouble(lukija.nextLine());

  Henkilo henkilo = new Henkilo(nimi, ika, paino, pituus);
  System.out.println(henkilo);
<% end %>

<% partial 'partials/sample_output' do %>
  Mikä on nimesi?
  <font color="red">Napoleone Buonaparte</font>
  Mikä on ikäsi?
  <font color="red">51</font>
  Mikä on painosi?
  <font color="red">80</font>
  Mikä on pituutesi?
  <font color="red">1.70</font>
  Napoleone Buonaparte, BMI: 27.68166089965398, maksimisyke: 170.03900000000002
<% end %>



<% partial 'partials/material_sub_sub_heading' do %>
  Luokka
<% end %>

<p>
  Luokka määrittelee minkälaisia olioita siitä voidaan luoda. Se sisältää olion tietoa kuvaavat oliomuuttujat, olion luomiseen käytettävän konstruktorin tai konstruktorit, sekä olion käyttäytymisen määrittelevät metodit. Alla on kuvattuna luokka Suorakulmio, joka määrittelee eräänlaisen suorakulmion toiminnallisuuden-
</p>

<% partial 'partials/code_highlight' do %>
  // luokka
  public class Suorakulmio {

      // oliomuuttujat
      private int leveys;
      private int korkeus;

      // konstruktori
      public Suorakulmio(int leveys, int korkeus) {
          this.leveys = leveys;
          this.korkeus = korkeus;
      }

      // metodit
      public void levenna() {
          this.leveys++;
      }

      public void kavenna() {
          if (this.leveys > 0) {
              this.leveys--;
          }
      }

      public int pintaAla() {
          return this.leveys * this.korkeus;
      }

      public String toString() {
          return "(" + this.leveys + ", " + this.korkeus + ")";
      }
  }
<% end %>

<p>
  Osa edellä määritellyistä metodeista ei palauta arvoa (metodit, joiden määrittelyssä käytetään avainsanaa void), ja osa metodeista palauttaa arvon (metodit, joiden määrittelyssä kerrotaan palautettavan muuttujan tyyppi). Yllä olevassa luokassa on määriteltynä myös metodi toString, jota käytetään olion sisäisen tilan tulostamiseen.
</p>

<p>
  Luokasta luodaan olioita konstruktorin avulla new-komennolla. Alla luodaan kaksi suorakulmiota ja tulostaan niihin liittyvää tietoa.
</p>

<% partial 'partials/code_highlight' do %>
  Suorakulmio eka = new Suorakulmio(40, 80);
  Suorakulmio nelio = new Suorakulmio(10, 10);
  System.out.println(eka);
  System.out.println(nelio);

  eka.kavenna();
  System.out.println(eka);
  System.out.println(eka.pintaAla());
<% end %>

<% partial 'partials/sample_output' do %>
  (40, 80)
  (10, 10)
  (39, 80)
  3920
<% end %>



<% partial 'partials/exercise', locals: { name: 'Kirja' } do %>

  <p>
    Luo kirjaa esittävä luokka <code>Kirja</code>. Jokaisella kirjalla on kirjailija, nimi ja sivujen lukumäärä.
  </p>
  
  <p>
    Tee luokalle:
  </p>
  
  <ul>
    <li>Konstruktori <code>public Kirja(String kirjailija, String nimi, int sivuja)</code></li>
    <li>Metodi <code>public String getKirjailija()</code> joka palauttaa kirjan kirjailijan nimen.</li>
    <li>Metodi <code>public String getNimi()</code> joka palauttaa kirjan nimen.</li>
    <li>Metodi <code>public int getSivuja()</code> joka palauttaa kirjan sivujen lukumäärän.</li>
    <li>Tee kirjalle lisäksi <code>public String toString()</code>-metodi, jota käytetään kirja-olion tulostamiseen. Metodin kutsun tulee tuottaa esimerkiksi seuraavanlainen tulostus:
      
      <% partial 'partials/sample_output' do %>
J. K. Rowling, Harry Potter ja viisasten kivi, 223 sivua
      <% end %>
      
    </li>
  </ul>
<% end %>



<% partial 'partials/exercise', locals: { name: 'Harjoitusapuri' } do %>

  <p>
    <a href="https://fi.wikipedia.org/wiki/Karvosen_kaava" target="_blank" norel>Karvosen kaavan</a> avulla voidaan laskea tavoitesyke fyysistä harjoittelua varten. Tavoitesykkeen laskeminen perustuu kaavaan <code>(maksimisyke - leposyke) * (tavoitesykeprosentti) + leposyke</code>, missä tavoitesyke annetaan prosenttina maksimisykkeestä.
  </p>

  <p>
    Esimerkiksi, jos henkilön maksimisyke on 200, leposyke 50, ja tavoitesyke 75% maksimisykkeestä, on tavoiteltava sydämen syke noin ((200-50) * (0.75) + 50) eli 162.5 lyöntiä minuutissa.
  </p>

  <p>
    Luo luokka <code>Harjoitusapuri</code>, jolle annetaan konstruktorin parametrina ikä ja leposyke. Harjoitusapurin tulee tarjota metodi tavoitesyke, jolle annetaan parametrina prosentuaalista maksimisykkeen osuutta kuvaava double-tyyppinen luku. Osuus annetaan lukuna nollan ja yhden välillä. Luokalla tulee olla:
  </p>

  <ul>
    <li>Konstruktori <code>public Harjoitusapuri(int ika, int leposyke)</code></li>
    <li>Metodi <code>public double tavoitesyke(double prosenttiaMaksimista)</code>, joka laskee ja palauttaa tavoiteltavan sykkeen.</li>
  </ul>

  <p>
    Käytä maksimisykkeen laskemiseen kaavaa <code>206.3 - (0.711 * ikä)</code>.
  </p>

  <p>
    Käyttöesimerkki:
  </p>
  
  
  <% partial 'partials/code_highlight' do %>
    Harjoitusapuri apuri = new Harjoitusapuri(30, 60);

    double prosenttiosuus = 0.5;

    while (prosenttiosuus &lt; 1.0) {
        double tavoite = apuri.tavoitesyke(prosenttiosuus);
        System.out.println("Tavoite " + (prosenttiosuus * 100) + "% maksimista: " + tavoite);
        prosenttiosuus += 0.1;
    }
  <% end %>
  
  <% partial 'partials/sample_output' do %>
    Tavoite 50.0% maksimista: 122.48500000000001
    Tavoite 60.0% maksimista: 134.98200000000003
    Tavoite 70.0% maksimista: 147.479
    Tavoite 80.0% maksimista: 159.976
    Tavoite 89.99999999999999% maksimista: 172.473
    Tavoite 99.99999999999999% maksimista: 184.97000000000003
  <% end %>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Kello laskurin avulla (4 osaa)' } do %>

  <p>
    Tässä tehtävässä tehdään luokka <code>YlhaaltaRajoitettuLaskuri</code> ja sovelletaan sitä kellon tekemiseen.
  </p>

  <h2>Rajoitettu laskuri</h2>

  <p>
    Tehdään luokka <code>YlhaaltaRajoitettuLaskuri</code>. Luokan olioilla on seuraava toiminnallisuus:
  </p>

  <ul>
    <li>Laskurilla on oliomuuttuja, joka muistaa laskurin arvon. Laskurin arvo on luku väliltä 0...yläraja.</li>
    <li>Aluksi laskurin arvo on 0.</li>
    <li>Olion konstruktori määrittää laskurin ylärajan.</li>
    <li>Metodi <code>seuraava</code> kasvattaa laskurin arvoa. Mutta jos laskurin arvo ylittää ylärajan, sen arvoksi tulee 0.</li>
    <li> Metodi <code>toString</code> palauttaa laskurin arvon merkkijonona.</li>
  </ul>

  <p>
    Tehtäväpohjassa on valmiina pääohjelmaa varten tiedosto <code>Paaohjelma</code>. Aloita tekemällä luokka <code>YlhaaltaRajoitettuLaskuri</code> vastaavasti kuin Maksukortti-tehtävässä. Näin tehdään myös tulevissa tehtäväsarjoissa.
  </p>

  <p>
    Luokan rungoksi tulee seuraava:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class YlhaaltaRajoitettuLaskuri {
        private int arvo;
        private int ylaraja;

        public YlhaaltaRajoitettuLaskuri(int ylarajanAlkuarvo) {
            // kirjoita koodia tähän
        }

        public void seuraava() {
            // kirjoita koodia tähän
        }

        public String toString() {
            // kirjoita koodia tähän
        }
    }
  <% end %>

  <p>
    <b>Vihje</b>: et voi palauttaa toStringissä suoraan kokonaislukutyyppisen oliomuuttujan <code>laskuri</code> arvoa. Kokonaislukumuuttujasta <code>arvo</code> saa merkkijonomuodon esim. lisäämällä sen eteen tyhjän merkkijonon eli kirjoittamalla <code>"" + arvo</code>.
  </p>

  <p>
    Seuraavassa on pääohjelma, joka käyttää laskuria:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            YlhaaltaRajoitettuLaskuri laskuri = new YlhaaltaRajoitettuLaskuri(4);
            System.out.println("arvo alussa: " + laskuri);

            int i = 0;
            while (i &lt; 10) {
                laskuri.seuraava();
                System.out.println("arvo: " + laskuri);
                i++;
            }
        }
    }
  <% end %>

  <p>
    Laskurille asetetaan konstruktorissa ylärajaksi 4, joten laskurin arvo on luku 0:n ja 4:n väliltä. Huomaa, miten metodi <code>seuraava</code> vie laskurin arvoa eteenpäin, kunnes se pyörähtää 4:n jälkeen 0:aan:
  </p>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    arvo alussa: 0
    arvo: 1
    arvo: 2
    arvo: 3
    arvo: 4
    arvo: 0
    arvo: 1
    arvo: 2
    arvo: 3
    arvo: 4
    arvo: 0
  <% end %>


  <h2>Etunolla tulostukseen</h2>

  <p>
    Tee <code>toString</code>-metodista sellainen, että se lisää arvon merkkijonoesitykseen etunollan, jos laskurin arvo on vähemmän kuin 10. Eli jos laskurin arvo on esim. 3, palautetaan merkkijono "03", jos arvo taas on esim. 12, palautetaan normaaliin tapaan merkkijono "12".
  </p>

  <p>
    Muuta pääohjelma seuraavaan muotoon ja varmista, että tulos on haluttu.
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            YlhaaltaRajoitettuLaskuri laskuri = new YlhaaltaRajoitettuLaskuri(14);
            System.out.println("arvo alussa: " + laskuri);
 
            int i = 0;
            while (i &lt; 16) {
                laskuri.seuraava();
                System.out.println("arvo: " + laskuri);
                i++;
            }
        }
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    arvo alussa: 00
    arvo: 01
    arvo: 02
    arvo: 03
    arvo: 04
    arvo: 05
    arvo: 06
    arvo: 07
    arvo: 08
    arvo: 09
    arvo: 10
    arvo: 11
    arvo: 12
    arvo: 13
    arvo: 14
    arvo: 00
    arvo: 01
  <% end %>


  <h2>Kello, ensimmäinen versio</h2>

  <p>
    Käyttämällä kahta laskuria voimme muodostaa kellon. Tuntimäärä on laskuri, jonka yläraja on 23, ja minuuttimäärä on laskuri jonka yläraja on 59. Kuten kaikki tietävät, kello toimii siten, että aina kun minuuttimäärä pyörähtää nollaan, tuntimäärä kasvaa yhdellä.
  </p>

  <p>
    Tee ensin laskurille metodi <code>arvo</code>, joka palauttaa laskurin arvon:
  </p>

  <% partial 'partials/code_highlight' do %>
    public int arvo() {
        // kirjoita koodia tähän
    }
  <% end %>

  <p>
    Tee sitten kello täydentämällä seuraava pääohjelmarunko (kopioi tämä pääohjelmaksesi sekä täydennä tarvittavilta osin kommenttien ohjaamalla tavalla):
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            YlhaaltaRajoitettuLaskuri minuutit = new YlhaaltaRajoitettuLaskuri(59);
            YlhaaltaRajoitettuLaskuri tunnit = new YlhaaltaRajoitettuLaskuri(23);

            int i = 0;
            while (i &lt; 121) {
                System.out.println(tunnit + ":" + minuutit);   // tulostetaan nykyinen aika
                // minuuttimäärä kasvaa
                // jos minuuttimäärä menee nollaan, tuntimäärä kasvaa

                i++;
            }
        }
    }
  <% end %>

  <p>
    Jos kellosi toimii oikein, sen tulostus näyttää suunnilleen seuraavalta:
  </p>

  <% partial 'partials/sample_output' do %>
    00:00
    00:01
    ...
    00:59
    01:00
    01:01
    01:02
    ...
    01:59
    02:00
  <% end %>


  <h2>Kello, toinen versio</h2>

  <p>
    Laajenna kelloasi myös sekuntiviisarilla. Tee lisäksi luokalle <code>YlhaaltaRajoitettuLaskuri</code> metodi <code>asetaArvo</code>, jolla laskurille pystyy asettamaan halutun arvon -- jos et ole ihan varma mitä tässä pitäisi tehdä, kertaa materiaalista kohta missä puhutaan "settereistä".
  </p>

  <p>
    Jos laskurille yritetään asettaa kelvoton arvo eli negatiivinen luku tai ylärajaa suurempi luku, ei laskurin arvo muutu.
  </p>

  <p>
    Tämän metodin avulla voit muuttaa kellon ajan heti ohjelman alussa haluamaksesi.
  </p>

  <p>
    Voit testata kellon toimintaa seuraavalla ohjelmalla
  </p>

  <% partial 'partials/code_highlight' do %>
    import java.util.Scanner;

    public class Paaohjelma {
        public static void main(String[] args)  {
            Scanner lukija = new Scanner(System.in);
            YlhaaltaRajoitettuLaskuri sekunnit = new YlhaaltaRajoitettuLaskuri(59);
            YlhaaltaRajoitettuLaskuri minuutit = new YlhaaltaRajoitettuLaskuri(59);
            YlhaaltaRajoitettuLaskuri tunnit = new YlhaaltaRajoitettuLaskuri(23);

            System.out.print("sekunnit: ");
            int sek = // kysy sekuntien alkuarvo käyttäjältä
            System.out.print("minuutit: ");
            int min = // kysy minuuttien alkuarvo käyttäjältä
            System.out.print("tunnit: ");
            int tun = // kysy tuntien alkuarvo käyttäjältä

            sekunnit.asetaArvo(sek);
            minuutit.asetaArvo(min);
            tunnit.asetaArvo(tun);

            int i = 0;
            while (i &lt; 121) {
                // lisää edelliseen myös sekuntiviisari
                i++;
            }

        }
    }
  <% end %>


  <p>
    Kokeile laittaa kellosi alkamaan ajasta <i>23:59:50</i> ja varmista, että vuorokauden vaihteessa kello toimii odotetusti!
  </p>

  <p>
    <strong>Bonus-tehtävä: ikuisesti käyvä kello (tehtävää ei palauteta!)</strong>
  </p>

  <p>
    Ennen kuin alat tekemään tätä tehtävää, palauta jo tekemäsi kello!
  </p>

  <p>
    Muuta pääohjelmasi seuraavaan muotoon:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) throws Exception {
            YlhaaltaRajoitettuLaskuri sekunnit = new YlhaaltaRajoitettuLaskuri(59);
            YlhaaltaRajoitettuLaskuri minuutit = new YlhaaltaRajoitettuLaskuri(59);
            YlhaaltaRajoitettuLaskuri tunnit = new YlhaaltaRajoitettuLaskuri(23);

            sekunnit.asetaArvo(50);
            minuutit.asetaArvo(59);
            tunnit.asetaArvo(23);

            while (true) {
                System.out.println(tunnit + ":" + minuutit + ":" + sekunnit);
                Thread.sleep(1000);
                // lisää kellon aikaa sekunnilla eteenpäin
            }
        }
    }
  <% end %>

  <p>
    Nyt kello käy ikuisesti ja kasvattaa arvoaan sekunnin välein. Sekunnin odotus tapahtuu komennolla <code>Thread.sleep(1000);</code>, komennon parametri kertoo nukuttavan ajan millisekunteina. Jotta komento toimisi, pitää main:in esittelyriville tehdä pieni lisäys: <code>public static void main(String[] args) <b>throws Exception</b> {</code>, eli tummennettuna oleva <code>throws Exception</code>.
  </p>

  <p>
    Saat ohjelman lopetettua painamalla NetBeans-konsolin (eli sen osan johon kello tulostaa arvonsa) vasemmalla laidalla olevasta punaisesta laatikosta.
  </p>

<% end %>





<% partial 'partials/material_heading' do %>
  Luokka- ja oliometodit: määre static
<% end %>




<p>
  Kurssin alussa kaikissa metodeissa esiintyi määre <code>static</code>, mutta aloittaessamme olioiden käytön, tuon määreen käyttö jopa kiellettiin. Mistä on kysymys?
</p>

<p>
  Seuraavassa esimerkissä on metodi <code>nollaaLista</code> joka toimii nimensä mukaisesti eli asettaa nollan parametrina saamansa listan kaikkien lukujen arvoksi.
</p>

<% partial 'partials/code_highlight' do %>
import java.util.ArrayList;

public class Ohjelma {

    public static void nollaaLista(ArrayList&lt;Integer&gt; lista) {
        for (int i = 0; i &lt; lista.size(); i++) {
            lista.set(i, 0);
        }
    }

    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
        luvut.add(1);
        luvut.add(2);
        luvut.add(3);
        luvut.add(4);
        luvut.add(5);

        for (int luku : luvut) {
            System.out.print(luku + " ");  // tulostuu 1 2 3 4 5
        }

        System.out.println();

        nollaaLista(luvut);

        for (int luku : luvut) {
            System.out.print(luku + " ");  // tulostuu 0 0 0 0 0
        }
    }
}
<% end %>

<p>
  Yllä olevassa esimerkissä metodilla <code>nollaaLista</code> on määre <code>static</code> ja sen kutsuminen tapahtuu ilman alussa olevaa olioviitettä.
</p>

<p>
  <em>Staattiset metodit</em> eivät liity olioon vaan luokkaan. Staattisia metodeja kutsutaan usein myös <em>luokkametodeiksi</em>. Toisin kuin olioiden metodit (joilla ei ole määrettä static), staattiseen metodiin ei liity olioa, eikä niillä voi muokata oliomuuttujia.
</p>

<p>
  Staattiselle metodille voi toki antaa olion parametrina. Staattinen metodi ei kuitenkaan voi käsitellä mitään muita lukuja, merkkijonoja, tai olioita kuin niitä, jotka annetaan sille parametrina, tai jotka se luo itse.
</p>

<p>
  Toisin sanoen, staattista metodia käyttävän koodin tulee antaa staattiselle metodille ne arvot ja oliot, joita staattisessa metodissa käsitellään.
</p>

<p>
  Koska staattinen metodi ei liity mihinkään olioon, ei sitä kutsuta oliometodien tapaan <code>olionNimi.metodinNimi()</code>, vaan ylläolevan esimerkin tapaan käytetään pelkkää staattisen metodin nimeä.
</p>

<p>
  Jos staattisen metodin koodi on eri luokan sisällä kuin sitä kutsuva metodi, voi staattista metodia kutsua muodossa <code>LuokanNimi.staattisenMetodinNimi()</code>. Edellinen esimerkki alla muutettuna siten, että pääohjelma ja metodi ovat omissa luokissaan (eli eri tiedostoissa):
</p>

<% partial 'partials/code_highlight' do %>
import java.util.ArrayList;

public class Ohjelma {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
        luvut.add(1);
        luvut.add(2);
        luvut.add(3);
        luvut.add(4);
        luvut.add(5);

        for (int luku : luvut) {
            System.out.print(luku + " ");  // tulostuu 1 2 3 4 5
        }

        System.out.println();

        ListaApurit.nollaaLista(luvut);

        for (int luku : luvut) {
            System.out.print(luku + " ");  // tulostuu 0 0 0 0 0
        }
    }
}
<% end %>

<% partial 'partials/code_highlight' do %>
import java.util.ArrayList;

public class ListaApurit {

    public static void nollaaLista(ArrayList&lt;Integer&gt; lista) {
        for (int i = 0; i &lt; lista.size(); i++) {
            lista.set(i, 0);
        }
    }
}
<% end %>

<p>Toisen luokan sisällä -- tässä tämän toisen luokan nimi on <code>ListaApurit</code> -- määriteltyä staattista metodia kutsutaan yllä muodossa <code>ListaApurit.nollaaLista(<em>parametri</em>);</code>.
</p>


<% partial 'partials/material_sub_heading' do %>
  Milloin staattisia metodeja tulisi käyttää
<% end %>

<p>
  Kaikki olion tilaa käsittelevät metodit tulee määritellä oliometodeina, joilla ei ole static-määrettä. Esimerkiksi edellisissä osissa määrittelemiemme luokkien kuten <code>Henkilo, Paivays, Soittolista, ...</code> kaikki metodit tulee määritellä ilman static-määrettä.
</p>

<p>
  Palataan vielä luokkaan <code>Henkilo</code>. Seuraavassa on osa luokan määritelmästä. Kaikkiin oliomuuttujiin viitataan <code>this</code>-määreen avulla sillä korostamme, että metodeissa käsitellään olion "sisällä" olevia oliomuuttujia.
</p>

<% partial 'partials/code_highlight' do %>
public class Henkilo {
    private String nimi;
    private int ika;

    public Henkilo(String nimi) {
        this.ika = 0;
        this.nimi = nimi;
    }

    public boolean taysiIkainen() {
        if (this.ika &lt; 18) {
            return false;
        }

        return true;
    }

    public void vanhene() {
        this.ika++;
    }

    public String getNimi() {
        return this.nimi;
    }
}
<% end %>

<p>
  Koska metodit käsittelevät oliota, ei niitä voi määrittää static:eiksi eli "olioista riippumattomiksi". Jos näin yritetään tehdä, ei metodi toimi. Esimerkiksi allaoleva <code>Henkilo</code>-olion iän muokkausta yrittävä metodi <code>vanhene</code> ei toimi:
</p>

<% partial 'partials/code_highlight' do %>
public class Henkilo {
    //...

    public static void vanhene() {
        this.ika++;
    }
}
<% end %>

<p>
  Seurauksena on virheilmoitus <em>non static variable ika can not be referenced from static context</em>, joka tarkoittaa että <em>oliomuuttujaan ei voida viitata luokkametodista</em>; staattinen metodi ei siis pysty käsittelemään oliomuuttujaa.
</p>

<p>
  Eli milloin staattista metodia sitten kannattaa käyttää? Tarkastellaan aiemmin materiaalissa nähtyä henkilöolioita käsittelevää esimerkkiä:
</p>

<% partial 'partials/code_highlight' do %>
public class Main {
    public static void main(String[] args) {
        Henkilo ada = new Henkilo("Ada");
        Henkilo antti = new Henkilo("Antti");
        Henkilo juhana = new Henkilo("Juhana");

        for (int i = 0; i &lt; 30; i++) {
            ada.vanhene();
            juhana.vanhene();
        }

        antti.vanhene();

        if (ada.taysiIkainen()) {
            System.out.println(ada.getNimi() + " on täysi-ikäinen");
        } else {
            System.out.println(ada.getNimi() + " on alaikäinen ");
        }

        if (antti.taysiIkainen()) {
            System.out.println(antti.getNimi() + " on täysi-ikäinen");
        } else {
            System.out.println(antti.getNimi() + " on alaikäinen");
        }

        if (juhana.taysiIkainen()) {
            System.out.println(juhana.getNimi() + " on täysi-ikäinen");
        } else {
            System.out.println(juhana.getNimi() + " on alaikäinen ");
        }
    }
}
<% end %>

<p>
  Huomaamme, että henkilöiden täysi-ikäisyyden ilmottamiseen liittyvä koodinpätkä on copy-pastettu kolme kertaa peräkkäin. Todella rumaa!
</p>

<p>
  Henkilön täysi-ikäisyyden ilmoittaminen on mainio kohde staattiselle metodille. Kirjoitetaan ohjelma uudelleen metodia hyödyntäen:
</p>

<% partial 'partials/code_highlight' do %>
public class Main {

    public static void main(String[] args) {
        Henkilo ada = new Henkilo("Ada");
        Henkilo antti = new Henkilo("Antti");
        Henkilo juhana = new Henkilo("Juhana");

        for (int i = 0; i &lt; 30; i++) {
            ada.vanhene();
            juhana.vanhene();
        }

        antti.vanhene();

        ilmoitaTaysiIkaisyys(ada);

        ilmoitaTaysiIkaisyys(antti);

        ilmoitaTaysiIkaisyys(juhana);
    }

    private static void ilmoitaTaysiIkaisyys(Henkilo henkilo) {
        if (henkilo.taysiIkainen()) {
            System.out.println(henkilo.getNimi() + " on täysi-ikäinen");
        } else {
            System.out.println(henkilo.getNimi() + " on alaikäinen");
        }
    }
}
<% end %>

<p>
  Metodi <code>ilmoitaTaysiIkaisyys</code> on määritelty staattiseksi, eli se ei liity mihinkään olioon, <strong>mutta</strong> metodi saa parametrikseen henkilöolion. Metodia ei ole määritelty Henkilö-luokan sisälle sillä vaikka se käsittelee parametrinaan saamaan henkilöolioa, se on juuri kirjoitetun pääohjelman apumetodi, jonka avulla pääohjelma on saatu kirjoitettua selkeämmin.
</p>


<% partial 'partials/exercise', locals: { name: 'Kirjaston tietojärjestelmä (4 osaa)' } do %>

  <p>
    Tässä tehtävässä kerrataan olio-ohjelmoinnin perusteita sekä listojen käsittelyä virran avulla.
  </p>

  <p>
    <em>
      Kumpulan tiedekirjasto tarvitsee uuden järjestelmän kirjojen hallintaan. Tässä tehtävässä hahmotellaan ongelma-alueen tietosisältöä ja toteutetaan prototyyppi, joka mahdollistaa kirjan haun nimen, julkaisijan tai julkaisuvuoden perusteella.
    </em>
  </p>

  <p>
    Rakennetaan järjestelmä osista, ensin toteutetaan oleelliset luokat eli <code>Kirja</code> ja <code>Kirjasto</code>. Luokka <code>Kirja</code> sisältää kirjaan liittyvät tiedot, luokka <code>Kirjasto</code> tarjoaa erilaisia hakutoiminnallisuuksia kirjoihin liittyen.
  </p>


  <h2>Kirja</h2>

  <p>
    Luodaan ensiksi luokka Kirja. Kirjalla on oliomuuttujina <code>nimeke</code>, eli kirjan nimi, <code>julkaisija</code>, eli kirjan julkaisija, ja <code>julkaisuvuosi</code> eli vuosi jolloin kirja on julkaistu. Kaksi ensimmäistä muuttujaa on merkkijonotyyppisiä, viimeisin on kokonaisluku. Oletamme tässä että kirjalla on aina vain yksi kirjoittaja.
  </p>

  <p>
    Toteuta luokka <code>Kirja</code>. Kirjalla tulee olla myös konstruktori <code>public Kirja(String niemeke, String julkaisija, int julkaisuvuosi)</code> sekä metodit <code>public String nimeke()</code>, <code>public String julkaisija()</code>, <code>public int julkaisuvuosi()</code> ja <code>public String toString()</code>. Arvannet mitä metodien tulee tehdä, alla esimerkki.
  </p>

  <p>
    Testaa luokan toimintaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    Kirja cheese = new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007);
    System.out.println(cheese.nimeke());
    System.out.println(cheese.julkaisija());
    System.out.println(cheese.julkaisuvuosi());

    System.out.println(cheese);
  <% end %>

  <% partial 'partials/sample_output' do %>
    Cheese Problems Solved
    Woodhead Publishing
    2007
    Cheese Problems Solved, Woodhead Publishing, 2007
  <% end %>


  <h2>Kirjasto</h2>

  <p>
    Kirjaston tehtävä on antaa käyttäjälle mahdollisuus kirjojen lisäämiseen ja niiden hakemiseen. Luo luokka <code>Kirjasto</code>, jolla on konstruktori <code>public Kirjasto()</code> ja metodit <code>public void lisaaKirja(Kirja uusiKirja)</code> ja <code>public void tulostaKirjat()</code>
  </p>

  <% partial 'partials/code_highlight' do %>
    Kirjasto kirjasto = new Kirjasto();

    Kirja cheese = new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007);
    kirjasto.lisaaKirja(cheese);

    Kirja nhl = new Kirja("NHL Hockey", "Stanley Kupp", 1952);
    kirjasto.lisaaKirja(nhl);

    kirjasto.lisaaKirja(new Kirja("Battle Axes", "Tom A. Hawk", 1851));

    kirjasto.tulostaKirjat();
  <% end %>

  <% partial 'partials/sample_output' do %>
    Cheese Problems Solved, Woodhead Publishing, 2007
    NHL Hockey, Stanley Kupp, 1952
    Battle Axes, Tom A. Hawk, 1851
  <% end %>


  <h2>Hakutoiminnallisuus</h2>

  <p>
    Kirjastosta tulee pystyä etsimään kirjoja nimekkeiden ja julkaisijoiden perusteella. Lisää kirjastolle metodit <code>public ArrayList&lt;Kirja&gt; haeKirjaNimekkeella(String nimeke)</code>, <code>public ArrayList&lt;Kirja&gt; haeKirjaJulkaisijalla(String julkaisija)</code> ja <code>public ArrayList&lt;Kirja&gt; haeKirjaJulkaisuvuodella(int julkaisuvuosi)</code>. Metodit palauttavat listan kirjoista, joissa on haluttu nimeke, julkaisija tai julkaisuvuosi.
  </p>

  <p>
    Voit halutessasi hyödyntää seuraavaa runkoa metodin tekemiseen.
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Kirjasto {
        // ...

        public ArrayList&lt;Kirja&gt; haeKirjaNimekkeella(String nimeke) {
            ArrayList&lt;Kirja&gt; loydetyt = new ArrayList&lt;&gt;();

            // käy läpi kaikki kirjat ja lisää ne joilla haetun kaltainen nimeke listalle loydetyt

            return loydetyt;
        }
    }
  <% end %>

  <p>
    Huom! Kun haet teet hakua merkkijonon avulla, älä tee tarkkaa hakua (metodi <code>equals</code>) vaan käytä <code>String</code>-luokan metodia <code>contains</code>. Huomaat todennäköisesti myös että sinulla on ns. copy-paste -koodia <code>Kirjasto</code>-luokan koodissa. Keksitkö tavan päästä siitä eroon?
  </p>

  <% partial 'partials/code_highlight' do %>
    Kirjasto kirjasto = new Kirjasto();

    kirjasto.lisaaKirja(new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007));
    kirjasto.lisaaKirja(new Kirja("The Stinky Cheese Man and Other Fairly Stupid Tales", "Penguin Group", 1992));
    kirjasto.lisaaKirja(new Kirja("NHL Hockey", "Stanley Kupp", 1952));
    kirjasto.lisaaKirja(new Kirja("Battle Axes", "Tom A. Hawk", 1851));

    for (Kirja kirja: kirjasto.haeKirjaNimekkeella("Cheese")) {
        System.out.println(kirja);
    }

    System.out.println("---");

    for (Kirja kirja: kirjasto.haeKirjaJulkaisijalla("Pong Group")) {
        System.out.println(kirja);
    }

    System.out.println("---");

    for (Kirja kirja: kirjasto.haeKirjaJulkaisuvuodella(1851)) {
        System.out.println(kirja);
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    Cheese Problems Solved, Woodhead Publishing, 2007
    The Stinky Cheese Man and Other Fairly Stupid Tales, Penguin Group, 1992
    ---
    ---
    Battle Axes, Tom A. Hawk, 1851
  <% end %>


  <h2>Paranneltu hakutoiminnallisuus</h2>

  <p>
    Hakutoiminnallisuutemme on jo hyvä, mutta se ei ymmärrä isojen ja pienten kirjainten eroa. Yllä olleessa esimerkissä haku nimekkeellä <code>"cheese"</code> ei olisi tuottanut yhtäkään tulosta. Myös toinen esimerkki, jossa oli ylimääräisiä välilyöntejä, ei näyttänyt haluttua tulosta. Haluamme että nimekkeiden ja julkaisijoiden nimillä haettaessa ei välitetä merkkien koosta, ja että käyttäjä voi syöttää ylimääräisiä välilyöntejä kirjan nimen alkuun tai loppuun (meidän ei tarvitse välittää sanojen välillä olevista tyhjistä!). Toteutetaan pieni apukirjasto <code>StringUtils</code> merkkijonojen vertailuun.
  </p>

  <p>
    Luo luokka <code>StringUtils</code>, ja lisää sille staattinen metodi <code>public static boolean sisaltaa(String sana, String haettava)</code>, joka tarkistaa sisältääkö merkkijono <code>sana</code> merkkijonon <code>haettava</code>. Jos jommankumman merkkijonon arvo on <em>null</em>, metodin tulee palauttaa arvo <code>false</code>. Metodin tarjoaman vertailun tulee olla välittämättä merkin koosta.
  </p>

  <p>
    Lisää metodille <code>sisaltaa</code> myös toiminnallisuus, joka poistaa merkkijonojen <code>sana</code> ja <code>haettava</code> alusta ja lopusta ylimääräiset välilyönnit. Käytä tähän <code>String</code>-luokan metodia <code>trim</code>, esim. <code>trimmattu = trimmattava.trim()</code>.
  </p>

  <p>
    Vinkki! <code>String</code>-luokan metodista <code>toUpperCase()</code> on hyötyä kun haluat verrata ovatko kaksi merkkijonoa samat -- riippumatta niiden alkuperäisestä merkkikoosta.
  </p>

  <p>
    Kun olet saanut metodin valmiiksi, käytä sitä <code>Kirjasto</code>-luokassa. Alla esimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
  if (StringUtils.sisaltaa(kirja.nimeke(), nimeke)) {
      // kirja löytyi!
  }
  <% end %>

  <% partial 'partials/code_highlight' do %>
  Kirjasto kirjasto = new Kirjasto();

  kirjasto.lisaaKirja(new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007));
  kirjasto.lisaaKirja(new Kirja("The Stinky Cheese Man and Other Fairly Stupid Tales", "Penguin Group", 1992));
  kirjasto.lisaaKirja(new Kirja("NHL Hockey", "Stanley Kupp", 1952));
  kirjasto.lisaaKirja(new Kirja("Battle Axes", "Tom A. Hawk", 1851));

  for (Kirja kirja: kirjasto.haeKirjaNimekkeella("CHEESE")) {
      System.out.println(kirja);
  }

  System.out.println("---");
  for (Kirja kirja: kirjasto.haeKirjaJulkaisijalla("PENGUIN  ")) {
      System.out.println(kirja);
  }
  <% end %>

  <% partial 'partials/sample_output' do %>
  Cheese Problems Solved, Woodhead Publishing, 2007
  The Stinky Cheese Man and Other Fairly Stupid Tales, Penguin Group, 1992
  ---
  The Stinky Cheese Man and Other Fairly Stupid Tales, Penguin Group, 1992
  <% end %>

<% end %>


